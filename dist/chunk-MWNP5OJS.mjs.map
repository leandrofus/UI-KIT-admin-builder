{"version":3,"sources":["../src/core/validators.ts","../src/core/utils.ts"],"names":[],"mappings":"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","file":"chunk-MWNP5OJS.mjs","sourcesContent":["/**\n * @fileoverview Pure validation functions for Dynamic UI Kit\n * \n * All validators are pure functions with no side effects.\n * They can be used independently or composed together.\n * \n * @module core/validators\n */\n\nimport type { \n  FieldValue,\n  PrimitiveValue,\n  ValidationRule, \n  FieldConfig, \n  DataRecord,\n  FieldCondition \n} from './types';\n\n// =============================================================================\n// VALIDATION RESULT TYPES\n// =============================================================================\n\n/**\n * Result of a single validation\n */\nexport interface ValidationResult {\n  /** Whether validation passed */\n  valid: boolean;\n  /** Error message if validation failed */\n  message?: string;\n}\n\n/**\n * Result of validating all fields\n */\nexport interface FormValidationResult {\n  /** Whether all validations passed */\n  valid: boolean;\n  /** Map of field names to error messages */\n  errors: Record<string, string>;\n}\n\n// =============================================================================\n// PRIMITIVE VALIDATORS\n// =============================================================================\n\n/**\n * Check if value is empty (null, undefined, empty string, empty array)\n */\nexport function isEmpty(value: FieldValue): boolean {\n  if (value === null || value === undefined) return true;\n  if (typeof value === 'string') return value.trim() === '';\n  if (Array.isArray(value)) return value.length === 0;\n  if (typeof value === 'object') return Object.keys(value).length === 0;\n  return false;\n}\n\n/**\n * Check if value is not empty\n */\nexport function isNotEmpty(value: FieldValue): boolean {\n  return !isEmpty(value);\n}\n\n/**\n * Validate required field\n */\nexport function validateRequired(value: FieldValue, message?: string): ValidationResult {\n  const valid = isNotEmpty(value);\n  return {\n    valid,\n    message: valid ? undefined : (message || 'Este campo es requerido'),\n  };\n}\n\n/**\n * Validate minimum value (for numbers)\n */\nexport function validateMin(value: FieldValue, min: number, message?: string): ValidationResult {\n  if (isEmpty(value)) return { valid: true };\n  \n  const numValue = typeof value === 'number' ? value : parseFloat(String(value));\n  if (isNaN(numValue)) return { valid: true };\n  \n  const valid = numValue >= min;\n  return {\n    valid,\n    message: valid ? undefined : (message || `El valor debe ser mayor o igual a ${min}`),\n  };\n}\n\n/**\n * Validate maximum value (for numbers)\n */\nexport function validateMax(value: FieldValue, max: number, message?: string): ValidationResult {\n  if (isEmpty(value)) return { valid: true };\n  \n  const numValue = typeof value === 'number' ? value : parseFloat(String(value));\n  if (isNaN(numValue)) return { valid: true };\n  \n  const valid = numValue <= max;\n  return {\n    valid,\n    message: valid ? undefined : (message || `El valor debe ser menor o igual a ${max}`),\n  };\n}\n\n/**\n * Validate minimum length (for strings and arrays)\n */\nexport function validateMinLength(value: FieldValue, minLength: number, message?: string): ValidationResult {\n  if (isEmpty(value)) return { valid: true };\n  \n  const length = typeof value === 'string' ? value.length : \n                 Array.isArray(value) ? value.length : 0;\n  \n  const valid = length >= minLength;\n  return {\n    valid,\n    message: valid ? undefined : (message || `Debe tener al menos ${minLength} caracteres`),\n  };\n}\n\n/**\n * Validate maximum length (for strings and arrays)\n */\nexport function validateMaxLength(value: FieldValue, maxLength: number, message?: string): ValidationResult {\n  if (isEmpty(value)) return { valid: true };\n  \n  const length = typeof value === 'string' ? value.length : \n                 Array.isArray(value) ? value.length : 0;\n  \n  const valid = length <= maxLength;\n  return {\n    valid,\n    message: valid ? undefined : (message || `No debe exceder ${maxLength} caracteres`),\n  };\n}\n\n/**\n * Validate against a regex pattern\n */\nexport function validatePattern(value: FieldValue, pattern: string | RegExp, message?: string): ValidationResult {\n  if (isEmpty(value)) return { valid: true };\n  \n  const regex = typeof pattern === 'string' ? new RegExp(pattern) : pattern;\n  const valid = regex.test(String(value));\n  \n  return {\n    valid,\n    message: valid ? undefined : (message || 'El formato no es válido'),\n  };\n}\n\n/**\n * Validate email format\n */\nexport function validateEmail(value: FieldValue, message?: string): ValidationResult {\n  if (isEmpty(value)) return { valid: true };\n  \n  // RFC 5322 compliant email regex (simplified)\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  const valid = emailRegex.test(String(value));\n  \n  return {\n    valid,\n    message: valid ? undefined : (message || 'El email no es válido'),\n  };\n}\n\n/**\n * Validate URL format\n */\nexport function validateUrl(value: FieldValue, message?: string): ValidationResult {\n  if (isEmpty(value)) return { valid: true };\n  \n  try {\n    new URL(String(value));\n    return { valid: true };\n  } catch {\n    return {\n      valid: false,\n      message: message || 'La URL no es válida',\n    };\n  }\n}\n\n/**\n * Validate phone number format (basic)\n */\nexport function validatePhone(value: FieldValue, message?: string): ValidationResult {\n  if (isEmpty(value)) return { valid: true };\n  \n  // Allow digits, spaces, dashes, parentheses, and + prefix\n  const phoneRegex = /^\\+?[\\d\\s\\-()]{6,20}$/;\n  const valid = phoneRegex.test(String(value));\n  \n  return {\n    valid,\n    message: valid ? undefined : (message || 'El teléfono no es válido'),\n  };\n}\n\n// =============================================================================\n// COMPOSITE VALIDATORS\n// =============================================================================\n\n/**\n * Apply a single validation rule to a value\n */\nexport function applyValidationRule(\n  value: FieldValue, \n  rule: ValidationRule,\n  formData?: DataRecord\n): ValidationResult {\n  switch (rule.type) {\n    case 'required':\n      return validateRequired(value, rule.message);\n    \n    case 'min':\n      return validateMin(value, rule.value as number, rule.message);\n    \n    case 'max':\n      return validateMax(value, rule.value as number, rule.message);\n    \n    case 'minLength':\n      return validateMinLength(value, rule.value as number, rule.message);\n    \n    case 'maxLength':\n      return validateMaxLength(value, rule.value as number, rule.message);\n    \n    case 'pattern':\n      return validatePattern(value, rule.value as string | RegExp, rule.message);\n    \n    case 'email':\n      return validateEmail(value, rule.message);\n    \n    case 'url':\n      return validateUrl(value, rule.message);\n    \n    case 'custom':\n      if (rule.validate) {\n        const result = rule.validate(value, formData);\n        if (typeof result === 'boolean') {\n          return { valid: result, message: result ? undefined : rule.message };\n        }\n        // Si devuelve string, es el mensaje de error\n        return { valid: false, message: result };\n      }\n      return { valid: true };\n    \n    default:\n      return { valid: true };\n  }\n}\n\n/**\n * Validate a field value against all its rules\n */\nexport function validateField(\n  value: FieldValue,\n  field: FieldConfig,\n  formData?: DataRecord\n): ValidationResult {\n  // Check required first\n  if (field.required) {\n    const requiredResult = validateRequired(value);\n    if (!requiredResult.valid) {\n      return requiredResult;\n    }\n  }\n  \n  // Skip other validations if empty and not required\n  if (isEmpty(value)) {\n    return { valid: true };\n  }\n  \n  // Apply all validation rules\n  if (field.validation) {\n    for (const rule of field.validation) {\n      const result = applyValidationRule(value, rule, formData);\n      if (!result.valid) {\n        return result;\n      }\n    }\n  }\n  \n  return { valid: true };\n}\n\n/**\n * Validate all fields in a form\n */\nexport function validateForm(\n  formData: DataRecord,\n  fields: FieldConfig[]\n): FormValidationResult {\n  const errors: Record<string, string> = {};\n  let valid = true;\n  \n  for (const field of fields) {\n    // Skip hidden or disabled fields\n    if (field.type === 'hidden' || field.disabled) {\n      continue;\n    }\n    \n    // Check showWhen condition\n    if (field.showWhen && !evaluateConditions(field.showWhen, formData)) {\n      continue;\n    }\n    \n    const value = formData[field.name];\n    const result = validateField(value, field, formData);\n    \n    if (!result.valid && result.message) {\n      errors[field.name] = result.message;\n      valid = false;\n    }\n  }\n  \n  return { valid, errors };\n}\n\n// =============================================================================\n// CONDITION EVALUATION\n// =============================================================================\n\n/**\n * Evaluate a single field condition\n */\nexport function evaluateCondition(condition: FieldCondition, formData: DataRecord): boolean {\n  const fieldValue = formData[condition.field];\n  const compareValue = condition.value;\n  \n  switch (condition.operator) {\n    case 'equals':\n      return fieldValue === compareValue;\n    \n    case 'notEquals':\n      return fieldValue !== compareValue;\n    \n    case 'contains':\n      if (typeof fieldValue === 'string' && typeof compareValue === 'string') {\n        return fieldValue.toLowerCase().includes(compareValue.toLowerCase());\n      }\n      if (Array.isArray(fieldValue)) {\n        return fieldValue.includes(compareValue as PrimitiveValue);\n      }\n      return false;\n    \n    case 'gt':\n      return Number(fieldValue) > Number(compareValue);\n    \n    case 'lt':\n      return Number(fieldValue) < Number(compareValue);\n    \n    case 'gte':\n      return Number(fieldValue) >= Number(compareValue);\n    \n    case 'lte':\n      return Number(fieldValue) <= Number(compareValue);\n    \n    case 'in':\n      if (Array.isArray(compareValue)) {\n        return compareValue.includes(fieldValue as PrimitiveValue);\n      }\n      return false;\n    \n    case 'notIn':\n      if (Array.isArray(compareValue)) {\n        return !compareValue.includes(fieldValue as PrimitiveValue);\n      }\n      return true;\n    \n    case 'isEmpty':\n      return isEmpty(fieldValue);\n    \n    case 'isNotEmpty':\n      return isNotEmpty(fieldValue);\n    \n    default:\n      return true;\n  }\n}\n\n/**\n * Evaluate multiple conditions (AND logic)\n */\nexport function evaluateConditions(\n  conditions: FieldCondition | FieldCondition[],\n  formData: DataRecord\n): boolean {\n  const conditionArray = Array.isArray(conditions) ? conditions : [conditions];\n  return conditionArray.every(c => evaluateCondition(c, formData));\n}\n\n// =============================================================================\n// CONFIG VALIDATORS\n// =============================================================================\n\n/**\n * Validate a field configuration\n */\nexport function validateFieldConfig(config: unknown): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n  \n  if (!config || typeof config !== 'object') {\n    errors.push('Field config must be an object');\n    return { valid: false, errors };\n  }\n  \n  const field = config as Record<string, unknown>;\n  \n  if (!field.name || typeof field.name !== 'string') {\n    errors.push('Field must have a \"name\" property (string)');\n  }\n  \n  if (!field.type || typeof field.type !== 'string') {\n    errors.push('Field must have a \"type\" property (string)');\n  }\n  \n  if (!field.label || typeof field.label !== 'string') {\n    errors.push('Field must have a \"label\" property (string)');\n  }\n  \n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * Validate a column configuration\n */\nexport function validateColumnConfig(config: unknown): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n  \n  if (!config || typeof config !== 'object') {\n    errors.push('Column config must be an object');\n    return { valid: false, errors };\n  }\n  \n  const column = config as Record<string, unknown>;\n  \n  if (!column.key || typeof column.key !== 'string') {\n    errors.push('Column must have a \"key\" property (string)');\n  }\n  \n  if (!column.accessor) {\n    errors.push('Column must have an \"accessor\" property');\n  }\n  \n  if (!column.header || typeof column.header !== 'string') {\n    errors.push('Column must have a \"header\" property (string)');\n  }\n  \n  if (!column.type || typeof column.type !== 'string') {\n    errors.push('Column must have a \"type\" property (string)');\n  }\n  \n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n","/**\n * @fileoverview Pure utility functions for Dynamic UI Kit\n * \n * All utilities are pure functions with no side effects.\n * They handle common operations like value access, formatting, and transformation.\n * \n * @module core/utils\n */\n\nimport type { \n  FieldValue, \n  DataRecord, \n  ColumnDataType,\n  SortDirection \n} from './types';\n\n// =============================================================================\n// VALUE ACCESS UTILITIES\n// =============================================================================\n\n/**\n * Get a nested value from an object using dot notation\n * \n * @example\n * getNestedValue({ user: { name: 'John' } }, 'user.name') // 'John'\n * getNestedValue({ items: [{ id: 1 }] }, 'items.0.id') // 1\n */\nexport function getNestedValue<T = FieldValue>(\n  obj: DataRecord | null | undefined,\n  path: string,\n  defaultValue?: T\n): T | undefined {\n  if (!obj || !path) {\n    return defaultValue;\n  }\n  \n  const keys = path.split('.');\n  let current: unknown = obj;\n  \n  for (const key of keys) {\n    if (current === null || current === undefined) {\n      return defaultValue;\n    }\n    \n    if (typeof current === 'object') {\n      current = (current as Record<string, unknown>)[key];\n    } else {\n      return defaultValue;\n    }\n  }\n  \n  return (current as T) ?? defaultValue;\n}\n\n/**\n * Set a nested value in an object using dot notation (immutably)\n * \n * @example\n * setNestedValue({ user: { name: 'John' } }, 'user.name', 'Jane')\n * // { user: { name: 'Jane' } }\n */\nexport function setNestedValue<T extends DataRecord>(\n  obj: T,\n  path: string,\n  value: FieldValue\n): T {\n  const keys = path.split('.');\n  const result = { ...obj };\n  \n  let current: Record<string, unknown> = result;\n  \n  for (let i = 0; i < keys.length - 1; i++) {\n    const key = keys[i];\n    current[key] = current[key] ? { ...current[key] as object } : {};\n    current = current[key] as Record<string, unknown>;\n  }\n  \n  current[keys[keys.length - 1]] = value;\n  \n  return result;\n}\n\n/**\n * Check if a value exists at the given path\n */\nexport function hasNestedValue(obj: DataRecord | null | undefined, path: string): boolean {\n  const value = getNestedValue(obj, path);\n  return value !== undefined && value !== null;\n}\n\n// =============================================================================\n// FORMATTING UTILITIES\n// =============================================================================\n\n/**\n * Locale configuration for formatting\n */\nexport interface FormatLocale {\n  locale?: string;\n  currency?: string;\n  timezone?: string;\n}\n\nconst DEFAULT_LOCALE: FormatLocale = {\n  locale: 'es-AR',\n  currency: 'ARS',\n  timezone: 'America/Argentina/Buenos_Aires',\n};\n\n/**\n * Format a value based on its column type\n */\nexport function formatValue(\n  value: FieldValue,\n  type: ColumnDataType,\n  options?: FormatLocale & { decimals?: number }\n): string {\n  if (value === null || value === undefined) {\n    return '';\n  }\n  \n  const { locale, currency, decimals } = { ...DEFAULT_LOCALE, ...options };\n  \n  switch (type) {\n    case 'text':\n      return String(value);\n    \n    case 'number':\n      if (typeof value === 'number' || !isNaN(Number(value))) {\n        return new Intl.NumberFormat(locale, {\n          minimumFractionDigits: decimals ?? 0,\n          maximumFractionDigits: decimals ?? 2,\n        }).format(Number(value));\n      }\n      return String(value);\n    \n    case 'currency':\n      if (typeof value === 'number' || !isNaN(Number(value))) {\n        return new Intl.NumberFormat(locale, {\n          style: 'currency',\n          currency: currency,\n          minimumFractionDigits: decimals ?? 2,\n          maximumFractionDigits: decimals ?? 2,\n        }).format(Number(value));\n      }\n      return String(value);\n    \n    case 'percent':\n      if (typeof value === 'number' || !isNaN(Number(value))) {\n        return new Intl.NumberFormat(locale, {\n          style: 'percent',\n          minimumFractionDigits: decimals ?? 0,\n          maximumFractionDigits: decimals ?? 2,\n        }).format(Number(value) / 100);\n      }\n      return String(value);\n    \n    case 'date':\n      return formatDate(value, { locale, includeTime: false });\n    \n    case 'datetime':\n      return formatDate(value, { locale, includeTime: true });\n    \n    case 'boolean':\n      return value ? 'Sí' : 'No';\n    \n    default:\n      return String(value);\n  }\n}\n\n/**\n * Format a date value\n */\nexport function formatDate(\n  value: FieldValue,\n  options?: { locale?: string; includeTime?: boolean; format?: string }\n): string {\n  if (!value) return '';\n  \n  const { locale = 'es-AR', includeTime = false } = options || {};\n  \n  let date: Date;\n  \n  if (value instanceof Date) {\n    date = value;\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    date = new Date(value);\n  } else {\n    return String(value);\n  }\n  \n  if (isNaN(date.getTime())) {\n    return String(value);\n  }\n  \n  const dateOptions: Intl.DateTimeFormatOptions = includeTime\n    ? { \n        year: 'numeric', \n        month: '2-digit', \n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit',\n      }\n    : { \n        year: 'numeric', \n        month: '2-digit', \n        day: '2-digit',\n      };\n  \n  return new Intl.DateTimeFormat(locale, dateOptions).format(date);\n}\n\n/**\n * Format a phone number\n */\nexport function formatPhone(value: FieldValue): string {\n  if (!value) return '';\n  \n  const digits = String(value).replace(/\\D/g, '');\n  \n  // Argentina format: +54 9 11 1234-5678\n  if (digits.startsWith('549') && digits.length >= 12) {\n    const area = digits.slice(3, 5);\n    const part1 = digits.slice(5, 9);\n    const part2 = digits.slice(9);\n    return `+54 9 ${area} ${part1}-${part2}`;\n  }\n  \n  // Generic format\n  if (digits.length >= 10) {\n    const area = digits.slice(0, 2);\n    const part1 = digits.slice(2, 6);\n    const part2 = digits.slice(6);\n    return `${area} ${part1}-${part2}`;\n  }\n  \n  return String(value);\n}\n\n// =============================================================================\n// SORTING UTILITIES\n// =============================================================================\n\n/**\n * Compare two values for sorting\n */\nexport function compareValues(\n  a: FieldValue,\n  b: FieldValue,\n  direction: SortDirection = 'asc',\n  type?: ColumnDataType\n): number {\n  // Handle null/undefined\n  if (a === null || a === undefined) return direction === 'asc' ? 1 : -1;\n  if (b === null || b === undefined) return direction === 'asc' ? -1 : 1;\n  \n  let comparison = 0;\n  \n  // Compare based on type\n  if (type === 'number' || type === 'currency' || type === 'percent') {\n    comparison = Number(a) - Number(b);\n  } else if (type === 'date' || type === 'datetime') {\n    comparison = new Date(a as string | number).getTime() - new Date(b as string | number).getTime();\n  } else if (type === 'boolean') {\n    comparison = (a ? 1 : 0) - (b ? 1 : 0);\n  } else {\n    // String comparison (case-insensitive)\n    comparison = String(a).toLowerCase().localeCompare(String(b).toLowerCase());\n  }\n  \n  return direction === 'desc' ? -comparison : comparison;\n}\n\n/**\n * Sort an array of records by a column\n */\nexport function sortData<T extends DataRecord>(\n  data: T[],\n  column: string,\n  direction: SortDirection,\n  type?: ColumnDataType\n): T[] {\n  if (!direction) return data;\n  \n  return [...data].sort((a, b) => {\n    const valueA = getNestedValue(a, column);\n    const valueB = getNestedValue(b, column);\n    return compareValues(valueA, valueB, direction, type);\n  });\n}\n\n// =============================================================================\n// SEARCH/FILTER UTILITIES\n// =============================================================================\n\n/**\n * Check if a value matches a search term\n */\nexport function matchesSearchTerm(value: FieldValue, term: string): boolean {\n  if (value === null || value === undefined) return false;\n  \n  const stringValue = String(value).toLowerCase();\n  const searchTerm = term.toLowerCase().trim();\n  \n  return stringValue.includes(searchTerm);\n}\n\n/**\n * Filter records by a global search term across specified columns\n */\nexport function filterBySearchTerm<T extends DataRecord>(\n  data: T[],\n  term: string,\n  columns: string[]\n): T[] {\n  if (!term.trim()) return data;\n  \n  return data.filter(row =>\n    columns.some(column => {\n      const value = getNestedValue(row, column);\n      return matchesSearchTerm(value, term);\n    })\n  );\n}\n\n// =============================================================================\n// PAGINATION UTILITIES\n// =============================================================================\n\n/**\n * Calculate pagination metadata\n */\nexport interface PaginationMeta {\n  totalPages: number;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n  startIndex: number;\n  endIndex: number;\n  displayRange: string;\n}\n\n/**\n * Calculate pagination metadata from total and page info\n */\nexport function calculatePagination(\n  total: number,\n  page: number,\n  pageSize: number\n): PaginationMeta {\n  const totalPages = Math.ceil(total / pageSize);\n  const startIndex = (page - 1) * pageSize;\n  const endIndex = Math.min(startIndex + pageSize, total);\n  \n  return {\n    totalPages,\n    hasNextPage: page < totalPages,\n    hasPreviousPage: page > 1,\n    startIndex,\n    endIndex,\n    displayRange: total > 0 \n      ? `${startIndex + 1}-${endIndex} de ${total}`\n      : '0 resultados',\n  };\n}\n\n/**\n * Paginate an array of data (client-side)\n */\nexport function paginateData<T>(data: T[], page: number, pageSize: number): T[] {\n  const startIndex = (page - 1) * pageSize;\n  return data.slice(startIndex, startIndex + pageSize);\n}\n\n// =============================================================================\n// ID/KEY UTILITIES\n// =============================================================================\n\n/**\n * Generate a unique ID\n */\nexport function generateId(prefix = 'duk'): string {\n  return `${prefix}_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;\n}\n\n/**\n * Get the row key value from a record\n */\nexport function getRowKey<T extends DataRecord>(\n  row: T,\n  rowKey: keyof T | string = 'id'\n): string | number {\n  const value = getNestedValue(row, String(rowKey));\n  return value !== undefined ? (value as string | number) : generateId('row');\n}\n\n// =============================================================================\n// OBJECT UTILITIES\n// =============================================================================\n\n/**\n * Deep merge two objects\n */\nexport function deepMerge<T extends Record<string, unknown>>(\n  target: T,\n  source: Partial<T>\n): T {\n  const result = { ...target };\n  \n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      const sourceValue = source[key];\n      const targetValue = result[key];\n      \n      if (\n        sourceValue !== null &&\n        typeof sourceValue === 'object' &&\n        !Array.isArray(sourceValue) &&\n        targetValue !== null &&\n        typeof targetValue === 'object' &&\n        !Array.isArray(targetValue)\n      ) {\n        result[key] = deepMerge(\n          targetValue as Record<string, unknown>,\n          sourceValue as Record<string, unknown>\n        ) as T[Extract<keyof T, string>];\n      } else {\n        result[key] = sourceValue as T[Extract<keyof T, string>];\n      }\n    }\n  }\n  \n  return result;\n}\n\n/**\n * Pick specific keys from an object\n */\nexport function pick<T extends Record<string, unknown>, K extends keyof T>(\n  obj: T,\n  keys: K[]\n): Pick<T, K> {\n  const result = {} as Pick<T, K>;\n  for (const key of keys) {\n    if (key in obj) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\n/**\n * Omit specific keys from an object\n */\nexport function omit<T extends Record<string, unknown>, K extends keyof T>(\n  obj: T,\n  keys: K[]\n): Omit<T, K> {\n  const result = { ...obj };\n  for (const key of keys) {\n    delete result[key];\n  }\n  return result as Omit<T, K>;\n}\n\n// =============================================================================\n// DEBOUNCE/THROTTLE UTILITIES\n// =============================================================================\n\n/**\n * Create a debounced function\n */\nexport function debounce<T extends (...args: unknown[]) => unknown>(\n  fn: T,\n  delay: number\n): (...args: Parameters<T>) => void {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n  \n  return (...args: Parameters<T>) => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      fn(...args);\n      timeoutId = null;\n    }, delay);\n  };\n}\n\n/**\n * Create a throttled function\n */\nexport function throttle<T extends (...args: unknown[]) => unknown>(\n  fn: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle = false;\n  \n  return (...args: Parameters<T>) => {\n    if (!inThrottle) {\n      fn(...args);\n      inThrottle = true;\n      setTimeout(() => {\n        inThrottle = false;\n      }, limit);\n    }\n  };\n}\n\n// =============================================================================\n// CLASS NAME UTILITIES\n// =============================================================================\n\n/**\n * Combine class names (similar to clsx/classnames)\n * Filters out falsy values and joins remaining strings with spaces\n */\nexport function cn(...classes: (string | number | undefined | null | false | 0)[]): string {\n  return classes.filter((c): c is string => typeof c === 'string' && c.length > 0).join(' ');\n}\n"]}