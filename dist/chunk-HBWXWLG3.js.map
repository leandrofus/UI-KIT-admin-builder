{"version":3,"sources":["../src/hooks/usePaginatedData.ts","../src/hooks/useFormState.ts","../src/hooks/useColumnConfig.ts","../src/hooks/useTableSelection.ts"],"names":["useState","useMemo","filterBySearchTerm","sortData","paginateData","calculatePagination","useEffect","useCallback","useRef","evaluateConditions","getNestedValue","validateField","validateForm","setNestedValue","getRowKey"],"mappings":"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","file":"chunk-HBWXWLG3.js","sourcesContent":["/**\n * @fileoverview Hook for managing paginated data state\n * \n * Handles pagination, sorting, and search state for tables.\n * Works with both client-side and server-side pagination.\n * \n * @module hooks/usePaginatedData\n */\n\nimport { useState, useMemo, useCallback, useEffect } from 'react';\nimport type { \n  DataRecord, \n  SortDirection, \n  PaginationConfig,\n  AdvancedFilter,\n  PaginatedResponse,\n  PaginationParams \n} from '../core/types';\nimport { \n  sortData, \n  filterBySearchTerm, \n  paginateData, \n  calculatePagination,\n  getNestedValue \n} from '../core/utils';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * State for paginated data\n */\nexport interface PaginatedDataState<T = DataRecord> {\n  /** Current data (after filtering, sorting, pagination) */\n  data: T[];\n  /** Total number of items (before pagination) */\n  total: number;\n  /** Current page (1-indexed) */\n  page: number;\n  /** Items per page */\n  pageSize: number;\n  /** Total number of pages */\n  totalPages: number;\n  /** Current sort column */\n  sortColumn: string | null;\n  /** Current sort direction */\n  sortDirection: SortDirection;\n  /** Current search term */\n  searchTerm: string;\n  /** Active advanced filters */\n  advancedFilters: AdvancedFilter[];\n  /** Whether data is loading */\n  isLoading: boolean;\n  /** Error message if any */\n  error: string | null;\n  /** Pagination display text */\n  displayRange: string;\n  /** Whether there is a next page */\n  hasNextPage: boolean;\n  /** Whether there is a previous page */\n  hasPreviousPage: boolean;\n}\n\n/**\n * Actions for paginated data\n */\nexport interface PaginatedDataActions<T = DataRecord> {\n  /** Go to a specific page */\n  goToPage: (page: number) => void;\n  /** Go to next page */\n  nextPage: () => void;\n  /** Go to previous page */\n  previousPage: () => void;\n  /** Change page size */\n  setPageSize: (size: number) => void;\n  /** Set sort column and direction */\n  setSort: (column: string, direction: SortDirection) => void;\n  /** Toggle sort for a column */\n  toggleSort: (column: string) => void;\n  /** Set search term */\n  setSearchTerm: (term: string) => void;\n  /** Set advanced filters */\n  setAdvancedFilters: (filters: AdvancedFilter[]) => void;\n  /** Add an advanced filter */\n  addFilter: (filter: AdvancedFilter) => void;\n  /** Remove an advanced filter */\n  removeFilter: (index: number) => void;\n  /** Clear all filters */\n  clearFilters: () => void;\n  /** Refresh data (for server-side) */\n  refresh: () => void;\n  /** Set data directly (for external updates) */\n  setData: (data: T[], total?: number) => void;\n  /** Set loading state */\n  setLoading: (loading: boolean) => void;\n  /** Set error state */\n  setError: (error: string | null) => void;\n  /** Reset to initial state */\n  reset: () => void;\n}\n\n/**\n * Options for usePaginatedData hook\n */\nexport interface UsePaginatedDataOptions<T = DataRecord> {\n  /** Initial data (for client-side pagination) */\n  initialData?: T[];\n  /** Total items (for server-side pagination) */\n  totalItems?: number;\n  /** Pagination configuration */\n  pagination?: PaginationConfig;\n  /** Initial sort column */\n  defaultSortColumn?: string;\n  /** Initial sort direction */\n  defaultSortDirection?: SortDirection;\n  /** Columns to search in (for client-side search) */\n  searchableColumns?: string[];\n  /** Data fetcher function (for server-side pagination) */\n  fetcher?: (params: PaginationParams) => Promise<PaginatedResponse<T>>;\n  /** Callback when pagination params change */\n  onParamsChange?: (params: PaginationParams) => void;\n  /** Whether to fetch on mount */\n  fetchOnMount?: boolean;\n}\n\n// =============================================================================\n// HOOK IMPLEMENTATION\n// =============================================================================\n\n/**\n * Hook for managing paginated data state\n * \n * @example\n * // Client-side pagination\n * const { state, actions } = usePaginatedData({\n *   initialData: products,\n *   pagination: { pageSize: 10 },\n *   searchableColumns: ['name', 'sku'],\n * });\n * \n * @example\n * // Server-side pagination\n * const { state, actions } = usePaginatedData({\n *   fetcher: async (params) => {\n *     const response = await api.get('/products', { params });\n *     return response.data;\n *   },\n *   pagination: { pageSize: 20 },\n * });\n */\nexport function usePaginatedData<T extends DataRecord = DataRecord>(\n  options: UsePaginatedDataOptions<T> = {}\n): { state: PaginatedDataState<T>; actions: PaginatedDataActions<T> } {\n  const {\n    initialData = [],\n    totalItems,\n    pagination = {},\n    defaultSortColumn = null,\n    defaultSortDirection = null,\n    searchableColumns = [],\n    fetcher,\n    onParamsChange,\n    fetchOnMount = true,\n  } = options;\n\n  const defaultPageSize = pagination.pageSize ?? 10;\n\n  // ==========================================================================\n  // STATE\n  // ==========================================================================\n\n  const [rawData, setRawData] = useState<T[]>(initialData);\n  const [serverTotal, setServerTotal] = useState<number | undefined>(totalItems);\n  const [page, setPage] = useState(1);\n  const [pageSize, setPageSize] = useState(defaultPageSize);\n  const [sortColumn, setSortColumn] = useState<string | null>(defaultSortColumn);\n  const [sortDirection, setSortDirection] = useState<SortDirection>(defaultSortDirection);\n  const [searchTerm, setSearchTerm] = useState('');\n  const [advancedFilters, setAdvancedFilters] = useState<AdvancedFilter[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [refreshCounter, setRefreshCounter] = useState(0);\n\n  // ==========================================================================\n  // COMPUTED VALUES\n  // ==========================================================================\n\n  // Is this server-side pagination?\n  const isServerSide = !!fetcher || serverTotal !== undefined;\n\n  // Process data (client-side only)\n  const processedData = useMemo(() => {\n    if (isServerSide) {\n      return rawData;\n    }\n\n    let result = [...rawData];\n\n    // Apply search filter\n    if (searchTerm && searchableColumns.length > 0) {\n      result = filterBySearchTerm(result, searchTerm, searchableColumns);\n    }\n\n    // Apply sorting\n    if (sortColumn && sortDirection) {\n      result = sortData(result, sortColumn, sortDirection);\n    }\n\n    return result;\n  }, [rawData, searchTerm, searchableColumns, sortColumn, sortDirection, isServerSide]);\n\n  // Calculate total\n  const total = isServerSide ? (serverTotal ?? 0) : processedData.length;\n\n  // Paginate (client-side only)\n  const paginatedData = useMemo(() => {\n    if (isServerSide) {\n      return rawData;\n    }\n    return paginateData(processedData, page, pageSize);\n  }, [processedData, page, pageSize, isServerSide, rawData]);\n\n  // Calculate pagination metadata\n  const paginationMeta = useMemo(\n    () => calculatePagination(total, page, pageSize),\n    [total, page, pageSize]\n  );\n\n  // ==========================================================================\n  // SERVER-SIDE FETCHING\n  // ==========================================================================\n\n  useEffect(() => {\n    if (!fetcher || (!fetchOnMount && refreshCounter === 0)) {\n      return;\n    }\n\n    const fetchData = async () => {\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const params: PaginationParams = {\n          page,\n          pageSize,\n          sortColumn: sortColumn ?? undefined,\n          sortDirection,\n        };\n\n        const response = await fetcher(params);\n        setRawData(response.data);\n        setServerTotal(response.total);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Error fetching data');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [fetcher, page, pageSize, sortColumn, sortDirection, refreshCounter, fetchOnMount]);\n\n  // Notify parent of param changes\n  useEffect(() => {\n    if (onParamsChange) {\n      onParamsChange({\n        page,\n        pageSize,\n        sortColumn: sortColumn ?? undefined,\n        sortDirection,\n      });\n    }\n  }, [page, pageSize, sortColumn, sortDirection, onParamsChange]);\n\n  // Reset to page 1 when filters change\n  useEffect(() => {\n    if (page !== 1) {\n      setPage(1);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [searchTerm, advancedFilters]);\n\n  // ==========================================================================\n  // ACTIONS\n  // ==========================================================================\n\n  const goToPage = useCallback((newPage: number) => {\n    const maxPage = Math.ceil(total / pageSize) || 1;\n    setPage(Math.max(1, Math.min(newPage, maxPage)));\n  }, [total, pageSize]);\n\n  const nextPage = useCallback(() => {\n    if (paginationMeta.hasNextPage) {\n      setPage(p => p + 1);\n    }\n  }, [paginationMeta.hasNextPage]);\n\n  const previousPage = useCallback(() => {\n    if (paginationMeta.hasPreviousPage) {\n      setPage(p => p - 1);\n    }\n  }, [paginationMeta.hasPreviousPage]);\n\n  const handleSetPageSize = useCallback((size: number) => {\n    setPageSize(size);\n    setPage(1); // Reset to first page when changing page size\n  }, []);\n\n  const setSort = useCallback((column: string, direction: SortDirection) => {\n    setSortColumn(column);\n    setSortDirection(direction);\n  }, []);\n\n  const toggleSort = useCallback((column: string) => {\n    if (sortColumn !== column) {\n      setSortColumn(column);\n      setSortDirection('asc');\n    } else if (sortDirection === 'asc') {\n      setSortDirection('desc');\n    } else if (sortDirection === 'desc') {\n      setSortColumn(null);\n      setSortDirection(null);\n    } else {\n      setSortDirection('asc');\n    }\n  }, [sortColumn, sortDirection]);\n\n  const handleSetSearchTerm = useCallback((term: string) => {\n    setSearchTerm(term);\n  }, []);\n\n  const handleSetAdvancedFilters = useCallback((filters: AdvancedFilter[]) => {\n    setAdvancedFilters(filters);\n  }, []);\n\n  const addFilter = useCallback((filter: AdvancedFilter) => {\n    setAdvancedFilters(prev => [...prev, filter]);\n  }, []);\n\n  const removeFilter = useCallback((index: number) => {\n    setAdvancedFilters(prev => prev.filter((_, i) => i !== index));\n  }, []);\n\n  const clearFilters = useCallback(() => {\n    setSearchTerm('');\n    setAdvancedFilters([]);\n  }, []);\n\n  const refresh = useCallback(() => {\n    setRefreshCounter(c => c + 1);\n  }, []);\n\n  const handleSetData = useCallback((data: T[], newTotal?: number) => {\n    setRawData(data);\n    if (newTotal !== undefined) {\n      setServerTotal(newTotal);\n    }\n  }, []);\n\n  const handleSetLoading = useCallback((loading: boolean) => {\n    setIsLoading(loading);\n  }, []);\n\n  const handleSetError = useCallback((err: string | null) => {\n    setError(err);\n  }, []);\n\n  const reset = useCallback(() => {\n    setRawData(initialData);\n    setServerTotal(totalItems);\n    setPage(1);\n    setPageSize(defaultPageSize);\n    setSortColumn(defaultSortColumn);\n    setSortDirection(defaultSortDirection);\n    setSearchTerm('');\n    setAdvancedFilters([]);\n    setIsLoading(false);\n    setError(null);\n  }, [initialData, totalItems, defaultPageSize, defaultSortColumn, defaultSortDirection]);\n\n  // ==========================================================================\n  // RETURN\n  // ==========================================================================\n\n  const state: PaginatedDataState<T> = {\n    data: paginatedData,\n    total,\n    page,\n    pageSize,\n    totalPages: paginationMeta.totalPages,\n    sortColumn,\n    sortDirection,\n    searchTerm,\n    advancedFilters,\n    isLoading,\n    error,\n    displayRange: paginationMeta.displayRange,\n    hasNextPage: paginationMeta.hasNextPage,\n    hasPreviousPage: paginationMeta.hasPreviousPage,\n  };\n\n  const actions: PaginatedDataActions<T> = {\n    goToPage,\n    nextPage,\n    previousPage,\n    setPageSize: handleSetPageSize,\n    setSort,\n    toggleSort,\n    setSearchTerm: handleSetSearchTerm,\n    setAdvancedFilters: handleSetAdvancedFilters,\n    addFilter,\n    removeFilter,\n    clearFilters,\n    refresh,\n    setData: handleSetData,\n    setLoading: handleSetLoading,\n    setError: handleSetError,\n    reset,\n  };\n\n  return { state, actions };\n}\n\nexport default usePaginatedData;\n","/**\n * @fileoverview Hook for managing form state\n * \n * Handles form values, validation, touched state, and submission.\n * Designed for dynamic forms with conditional fields.\n * \n * @module hooks/useFormState\n */\n\nimport { useState, useCallback, useMemo, useRef } from 'react';\nimport type { \n  DataRecord, \n  FieldValue, \n  FieldConfig, \n  FormSection,\n  FieldCondition \n} from '../core/types';\nimport { \n  validateField, \n  validateForm, \n  evaluateConditions,\n  isEmpty \n} from '../core/validators';\nimport { setNestedValue, getNestedValue } from '../core/utils';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Form state\n */\nexport interface FormState<T = DataRecord> {\n  /** Current form values */\n  values: T;\n  /** Validation errors by field name */\n  errors: Record<string, string>;\n  /** Which fields have been touched */\n  touched: Record<string, boolean>;\n  /** Whether form is currently submitting */\n  isSubmitting: boolean;\n  /** Whether form has been modified */\n  isDirty: boolean;\n  /** Whether form is valid */\n  isValid: boolean;\n  /** Submit count */\n  submitCount: number;\n}\n\n/**\n * Form actions\n */\nexport interface FormActions<T = DataRecord> {\n  /** Set a single field value */\n  setValue: (name: string, value: FieldValue) => void;\n  /** Set multiple values at once */\n  setValues: (values: Partial<T>) => void;\n  /** Mark a field as touched */\n  setTouched: (name: string, isTouched?: boolean) => void;\n  /** Mark multiple fields as touched */\n  setAllTouched: () => void;\n  /** Set a field error manually */\n  setError: (name: string, error: string | undefined) => void;\n  /** Clear all errors */\n  clearErrors: () => void;\n  /** Validate a single field */\n  validateField: (name: string) => boolean;\n  /** Validate all fields */\n  validateAll: () => boolean;\n  /** Handle field change (sets value and optionally validates) */\n  handleChange: (name: string, value: FieldValue) => void;\n  /** Handle field blur (marks touched and validates) */\n  handleBlur: (name: string) => void;\n  /** Submit the form */\n  handleSubmit: (e?: React.FormEvent) => Promise<void>;\n  /** Reset form to initial values */\n  reset: (newValues?: Partial<T>) => void;\n  /** Get field props helper */\n  getFieldProps: (name: string) => FieldProps;\n  /** Check if a field should be visible */\n  isFieldVisible: (field: FieldConfig) => boolean;\n  /** Get all visible fields from sections */\n  getVisibleFields: (sections: FormSection[]) => FieldConfig[];\n}\n\n/**\n * Props to spread on a field component\n */\nexport interface FieldProps {\n  name: string;\n  value: FieldValue;\n  error?: string;\n  touched: boolean;\n  onChange: (value: FieldValue) => void;\n  onBlur: () => void;\n}\n\n/**\n * Options for useFormState hook\n */\nexport interface UseFormStateOptions<T = DataRecord> {\n  /** Initial form values */\n  initialValues: T;\n  /** Field configurations for validation */\n  fields?: FieldConfig[];\n  /** Form sections (alternative to fields) */\n  sections?: FormSection[];\n  /** Validation mode */\n  validationMode?: 'onChange' | 'onBlur' | 'onSubmit';\n  /** Submit handler */\n  onSubmit?: (values: T) => void | Promise<void>;\n  /** Change handler */\n  onChange?: (name: string, value: FieldValue, values: T) => void;\n  /** Validation error handler */\n  onValidationError?: (errors: Record<string, string>) => void;\n  /** Whether to validate on mount */\n  validateOnMount?: boolean;\n}\n\n// =============================================================================\n// HOOK IMPLEMENTATION\n// =============================================================================\n\n/**\n * Hook for managing form state\n * \n * @example\n * const { state, actions } = useFormState({\n *   initialValues: { name: '', email: '' },\n *   fields: [\n *     { name: 'name', type: 'text', label: 'Name', required: true },\n *     { name: 'email', type: 'email', label: 'Email', required: true },\n *   ],\n *   onSubmit: async (values) => {\n *     await api.post('/users', values);\n *   },\n * });\n */\nexport function useFormState<T extends DataRecord = DataRecord>(\n  options: UseFormStateOptions<T>\n): { state: FormState<T>; actions: FormActions<T> } {\n  const {\n    initialValues,\n    fields: fieldsProp = [],\n    sections = [],\n    validationMode = 'onBlur',\n    onSubmit,\n    onChange,\n    onValidationError,\n    validateOnMount = false,\n  } = options;\n\n  // Extract fields from sections if provided\n  const fields = useMemo(() => {\n    if (fieldsProp.length > 0) return fieldsProp;\n    return sections.flatMap(section => section.fields);\n  }, [fieldsProp, sections]);\n\n  // ==========================================================================\n  // STATE\n  // ==========================================================================\n\n  const [values, setValues] = useState<T>(initialValues);\n  const [errors, setErrors] = useState<Record<string, string>>({});\n  const [touched, setTouched] = useState<Record<string, boolean>>({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [submitCount, setSubmitCount] = useState(0);\n\n  // Keep track of initial values for dirty check\n  const initialValuesRef = useRef(initialValues);\n\n  // ==========================================================================\n  // COMPUTED\n  // ==========================================================================\n\n  const isDirty = useMemo(() => {\n    return JSON.stringify(values) !== JSON.stringify(initialValuesRef.current);\n  }, [values]);\n\n  const isValid = useMemo(() => {\n    return Object.keys(errors).length === 0;\n  }, [errors]);\n\n  // ==========================================================================\n  // FIELD VISIBILITY\n  // ==========================================================================\n\n  const isFieldVisible = useCallback((field: FieldConfig): boolean => {\n    if (!field.showWhen) return true;\n    return evaluateConditions(field.showWhen, values as DataRecord);\n  }, [values]);\n\n  const getVisibleFields = useCallback((formSections: FormSection[]): FieldConfig[] => {\n    return formSections\n      .filter(section => {\n        if (!section.showWhen) return true;\n        return evaluateConditions(section.showWhen, values as DataRecord);\n      })\n      .flatMap(section => section.fields.filter(isFieldVisible));\n  }, [values, isFieldVisible]);\n\n  // ==========================================================================\n  // VALIDATION\n  // ==========================================================================\n\n  const validateSingleField = useCallback((name: string): boolean => {\n    const field = fields.find(f => f.name === name);\n    if (!field) return true;\n\n    // Skip validation for hidden fields\n    if (!isFieldVisible(field)) {\n      setErrors(prev => {\n        const { [name]: _, ...rest } = prev;\n        return rest;\n      });\n      return true;\n    }\n\n    const value = getNestedValue(values as DataRecord, name);\n    const result = validateField(value, field, values as DataRecord);\n\n    if (!result.valid && result.message) {\n      setErrors(prev => ({ ...prev, [name]: result.message! }));\n      return false;\n    } else {\n      setErrors(prev => {\n        const { [name]: _, ...rest } = prev;\n        return rest;\n      });\n      return true;\n    }\n  }, [fields, values, isFieldVisible]);\n\n  const validateAllFields = useCallback((): boolean => {\n    const visibleFields = fields.filter(isFieldVisible);\n    const result = validateForm(values as DataRecord, visibleFields);\n\n    setErrors(result.errors);\n\n    if (!result.valid && onValidationError) {\n      onValidationError(result.errors);\n    }\n\n    return result.valid;\n  }, [fields, values, isFieldVisible, onValidationError]);\n\n  // ==========================================================================\n  // ACTIONS\n  // ==========================================================================\n\n  const setValue = useCallback((name: string, value: FieldValue) => {\n    setValues(prev => setNestedValue(prev as DataRecord, name, value) as T);\n\n    // Call onChange callback\n    if (onChange) {\n      const newValues = setNestedValue(values as DataRecord, name, value) as T;\n      onChange(name, value, newValues);\n    }\n\n    // Validate on change if configured\n    if (validationMode === 'onChange' && touched[name]) {\n      // Defer validation to next tick to use updated values\n      setTimeout(() => validateSingleField(name), 0);\n    }\n  }, [onChange, values, validationMode, touched, validateSingleField]);\n\n  const setMultipleValues = useCallback((newValues: Partial<T>) => {\n    setValues(prev => ({ ...prev, ...newValues }));\n  }, []);\n\n  const setFieldTouched = useCallback((name: string, isTouched = true) => {\n    setTouched(prev => ({ ...prev, [name]: isTouched }));\n  }, []);\n\n  const setAllFieldsTouched = useCallback(() => {\n    const allTouched: Record<string, boolean> = {};\n    fields.forEach(field => {\n      allTouched[field.name] = true;\n    });\n    setTouched(allTouched);\n  }, [fields]);\n\n  const setFieldError = useCallback((name: string, error: string | undefined) => {\n    if (error) {\n      setErrors(prev => ({ ...prev, [name]: error }));\n    } else {\n      setErrors(prev => {\n        const { [name]: _, ...rest } = prev;\n        return rest;\n      });\n    }\n  }, []);\n\n  const clearAllErrors = useCallback(() => {\n    setErrors({});\n  }, []);\n\n  const handleChange = useCallback((name: string, value: FieldValue) => {\n    setValue(name, value);\n  }, [setValue]);\n\n  const handleBlur = useCallback((name: string) => {\n    setFieldTouched(name, true);\n\n    if (validationMode === 'onBlur' || validationMode === 'onChange') {\n      validateSingleField(name);\n    }\n  }, [setFieldTouched, validationMode, validateSingleField]);\n\n  const handleSubmit = useCallback(async (e?: React.FormEvent) => {\n    if (e) {\n      e.preventDefault();\n    }\n\n    setSubmitCount(c => c + 1);\n    setAllFieldsTouched();\n\n    const isFormValid = validateAllFields();\n\n    if (!isFormValid) {\n      return;\n    }\n\n    if (onSubmit) {\n      setIsSubmitting(true);\n      try {\n        await onSubmit(values);\n      } finally {\n        setIsSubmitting(false);\n      }\n    }\n  }, [setAllFieldsTouched, validateAllFields, onSubmit, values]);\n\n  const reset = useCallback((newValues?: Partial<T>) => {\n    const resetValues = newValues \n      ? { ...initialValuesRef.current, ...newValues }\n      : initialValuesRef.current;\n    \n    setValues(resetValues);\n    setErrors({});\n    setTouched({});\n    setIsSubmitting(false);\n    setSubmitCount(0);\n\n    if (newValues) {\n      initialValuesRef.current = resetValues;\n    }\n  }, []);\n\n  const getFieldProps = useCallback((name: string): FieldProps => {\n    return {\n      name,\n      value: getNestedValue(values as DataRecord, name),\n      error: touched[name] ? errors[name] : undefined,\n      touched: touched[name] || false,\n      onChange: (value: FieldValue) => handleChange(name, value),\n      onBlur: () => handleBlur(name),\n    };\n  }, [values, errors, touched, handleChange, handleBlur]);\n\n  // ==========================================================================\n  // RETURN\n  // ==========================================================================\n\n  const state: FormState<T> = {\n    values,\n    errors,\n    touched,\n    isSubmitting,\n    isDirty,\n    isValid,\n    submitCount,\n  };\n\n  const actions: FormActions<T> = {\n    setValue,\n    setValues: setMultipleValues,\n    setTouched: setFieldTouched,\n    setAllTouched: setAllFieldsTouched,\n    setError: setFieldError,\n    clearErrors: clearAllErrors,\n    validateField: validateSingleField,\n    validateAll: validateAllFields,\n    handleChange,\n    handleBlur,\n    handleSubmit,\n    reset,\n    getFieldProps,\n    isFieldVisible,\n    getVisibleFields,\n  };\n\n  return { state, actions };\n}\n\nexport default useFormState;\n","/**\n * @fileoverview Hook for managing table column configuration\n * \n * Handles column visibility, ordering, and resizing.\n * \n * @module hooks/useColumnConfig\n */\n\nimport { useState, useCallback, useMemo } from 'react';\nimport type { ColumnConfig, DataRecord, SortDirection } from '../core/types';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Column state (visibility, order, width)\n */\nexport interface ColumnState {\n  /** Column key */\n  key: string;\n  /** Whether column is visible */\n  visible: boolean;\n  /** Column width (if customized) */\n  width?: number | string;\n  /** Column order index */\n  order: number;\n}\n\n/**\n * Column configuration state\n */\nexport interface ColumnConfigState {\n  /** Column states by key */\n  columns: Record<string, ColumnState>;\n  /** Ordered list of visible column keys */\n  visibleColumnKeys: string[];\n  /** Current sort column */\n  sortColumn: string | null;\n  /** Current sort direction */\n  sortDirection: SortDirection;\n}\n\n/**\n * Column configuration actions\n */\nexport interface ColumnConfigActions {\n  /** Toggle column visibility */\n  toggleColumn: (key: string) => void;\n  /** Set column visibility */\n  setColumnVisible: (key: string, visible: boolean) => void;\n  /** Set column width */\n  setColumnWidth: (key: string, width: number | string) => void;\n  /** Reorder columns */\n  reorderColumns: (fromIndex: number, toIndex: number) => void;\n  /** Move column to position */\n  moveColumn: (key: string, toIndex: number) => void;\n  /** Reset to default configuration */\n  reset: () => void;\n  /** Get ordered visible columns */\n  getVisibleColumns: <T extends DataRecord>() => ColumnConfig<T>[];\n  /** Set sort */\n  setSort: (column: string | null, direction: SortDirection) => void;\n  /** Toggle sort for a column */\n  toggleSort: (column: string) => void;\n  /** Save configuration (to localStorage or callback) */\n  save: () => void;\n  /** Load saved configuration */\n  load: () => void;\n}\n\n/**\n * Options for useColumnConfig hook\n */\nexport interface UseColumnConfigOptions<T extends DataRecord = DataRecord> {\n  /** Column configurations */\n  columns: ColumnConfig<T>[];\n  /** Storage key for persistence */\n  storageKey?: string;\n  /** Default sort column */\n  defaultSortColumn?: string;\n  /** Default sort direction */\n  defaultSortDirection?: SortDirection;\n  /** Callback when configuration changes */\n  onConfigChange?: (config: ColumnConfigState) => void;\n}\n\n// =============================================================================\n// HOOK IMPLEMENTATION\n// =============================================================================\n\n/**\n * Hook for managing table column configuration\n * \n * @example\n * const { state, actions } = useColumnConfig({\n *   columns: tableColumns,\n *   storageKey: 'products-table-config',\n * });\n * \n * // Toggle column visibility\n * actions.toggleColumn('description');\n * \n * // Get visible columns for rendering\n * const visibleColumns = actions.getVisibleColumns();\n */\nexport function useColumnConfig<T extends DataRecord = DataRecord>(\n  options: UseColumnConfigOptions<T>\n): { state: ColumnConfigState; actions: ColumnConfigActions } {\n  const {\n    columns: initialColumns,\n    storageKey,\n    defaultSortColumn = null,\n    defaultSortDirection = null,\n    onConfigChange,\n  } = options;\n\n  // ==========================================================================\n  // INITIAL STATE\n  // ==========================================================================\n\n  const getInitialState = useCallback((): ColumnConfigState => {\n    // Try to load from storage\n    if (storageKey && typeof window !== 'undefined') {\n      try {\n        const saved = localStorage.getItem(storageKey);\n        if (saved) {\n          return JSON.parse(saved);\n        }\n      } catch (e) {\n        console.warn('Failed to load column config from storage:', e);\n      }\n    }\n\n    // Build default state from columns\n    const columnsState: Record<string, ColumnState> = {};\n    initialColumns.forEach((col, index) => {\n      columnsState[col.key] = {\n        key: col.key,\n        visible: col.visible !== false,\n        width: col.width,\n        order: index,\n      };\n    });\n\n    const visibleKeys = initialColumns\n      .filter(col => col.visible !== false)\n      .map(col => col.key);\n\n    return {\n      columns: columnsState,\n      visibleColumnKeys: visibleKeys,\n      sortColumn: defaultSortColumn,\n      sortDirection: defaultSortDirection,\n    };\n  }, [initialColumns, storageKey, defaultSortColumn, defaultSortDirection]);\n\n  // ==========================================================================\n  // STATE\n  // ==========================================================================\n\n  const [state, setState] = useState<ColumnConfigState>(getInitialState);\n\n  // ==========================================================================\n  // MEMOIZED VALUES\n  // ==========================================================================\n\n  const columnMap = useMemo(() => {\n    const map = new Map<string, ColumnConfig<T>>();\n    initialColumns.forEach(col => map.set(col.key, col));\n    return map;\n  }, [initialColumns]);\n\n  // ==========================================================================\n  // ACTIONS\n  // ==========================================================================\n\n  const updateState = useCallback((updater: (prev: ColumnConfigState) => ColumnConfigState) => {\n    setState(prev => {\n      const newState = updater(prev);\n      if (onConfigChange) {\n        onConfigChange(newState);\n      }\n      return newState;\n    });\n  }, [onConfigChange]);\n\n  const toggleColumn = useCallback((key: string) => {\n    updateState(prev => {\n      const column = prev.columns[key];\n      if (!column) return prev;\n\n      const newVisible = !column.visible;\n      const newColumns = {\n        ...prev.columns,\n        [key]: { ...column, visible: newVisible },\n      };\n\n      const newVisibleKeys = newVisible\n        ? [...prev.visibleColumnKeys, key].sort((a, b) => {\n            return (prev.columns[a]?.order ?? 0) - (prev.columns[b]?.order ?? 0);\n          })\n        : prev.visibleColumnKeys.filter(k => k !== key);\n\n      return {\n        ...prev,\n        columns: newColumns,\n        visibleColumnKeys: newVisibleKeys,\n      };\n    });\n  }, [updateState]);\n\n  const setColumnVisible = useCallback((key: string, visible: boolean) => {\n    updateState(prev => {\n      const column = prev.columns[key];\n      if (!column || column.visible === visible) return prev;\n\n      const newColumns = {\n        ...prev.columns,\n        [key]: { ...column, visible },\n      };\n\n      const newVisibleKeys = visible\n        ? [...prev.visibleColumnKeys, key].sort((a, b) => {\n            return (prev.columns[a]?.order ?? 0) - (prev.columns[b]?.order ?? 0);\n          })\n        : prev.visibleColumnKeys.filter(k => k !== key);\n\n      return {\n        ...prev,\n        columns: newColumns,\n        visibleColumnKeys: newVisibleKeys,\n      };\n    });\n  }, [updateState]);\n\n  const setColumnWidth = useCallback((key: string, width: number | string) => {\n    updateState(prev => {\n      const column = prev.columns[key];\n      if (!column) return prev;\n\n      return {\n        ...prev,\n        columns: {\n          ...prev.columns,\n          [key]: { ...column, width },\n        },\n      };\n    });\n  }, [updateState]);\n\n  const reorderColumns = useCallback((fromIndex: number, toIndex: number) => {\n    updateState(prev => {\n      const keys = [...prev.visibleColumnKeys];\n      const [removed] = keys.splice(fromIndex, 1);\n      keys.splice(toIndex, 0, removed);\n\n      // Update order in column states\n      const newColumns = { ...prev.columns };\n      keys.forEach((key, index) => {\n        if (newColumns[key]) {\n          newColumns[key] = { ...newColumns[key], order: index };\n        }\n      });\n\n      return {\n        ...prev,\n        columns: newColumns,\n        visibleColumnKeys: keys,\n      };\n    });\n  }, [updateState]);\n\n  const moveColumn = useCallback((key: string, toIndex: number) => {\n    updateState(prev => {\n      const fromIndex = prev.visibleColumnKeys.indexOf(key);\n      if (fromIndex === -1) return prev;\n\n      const keys = [...prev.visibleColumnKeys];\n      keys.splice(fromIndex, 1);\n      keys.splice(toIndex, 0, key);\n\n      // Update order in column states\n      const newColumns = { ...prev.columns };\n      keys.forEach((k, index) => {\n        if (newColumns[k]) {\n          newColumns[k] = { ...newColumns[k], order: index };\n        }\n      });\n\n      return {\n        ...prev,\n        columns: newColumns,\n        visibleColumnKeys: keys,\n      };\n    });\n  }, [updateState]);\n\n  const setSort = useCallback((column: string | null, direction: SortDirection) => {\n    updateState(prev => ({\n      ...prev,\n      sortColumn: column,\n      sortDirection: direction,\n    }));\n  }, [updateState]);\n\n  const toggleSort = useCallback((column: string) => {\n    updateState(prev => {\n      if (prev.sortColumn !== column) {\n        return { ...prev, sortColumn: column, sortDirection: 'asc' };\n      } else if (prev.sortDirection === 'asc') {\n        return { ...prev, sortDirection: 'desc' };\n      } else if (prev.sortDirection === 'desc') {\n        return { ...prev, sortColumn: null, sortDirection: null };\n      } else {\n        return { ...prev, sortDirection: 'asc' };\n      }\n    });\n  }, [updateState]);\n\n  const reset = useCallback(() => {\n    setState(getInitialState());\n    if (storageKey && typeof window !== 'undefined') {\n      localStorage.removeItem(storageKey);\n    }\n  }, [getInitialState, storageKey]);\n\n  const getVisibleColumns = useCallback(<TData extends DataRecord>(): ColumnConfig<TData>[] => {\n    return state.visibleColumnKeys\n      .map(key => columnMap.get(key))\n      .filter((col): col is ColumnConfig<T> => col !== undefined)\n      .map(col => {\n        const colState = state.columns[col.key];\n        if (colState?.width) {\n          return { ...col, width: colState.width } as ColumnConfig<TData>;\n        }\n        return col as unknown as ColumnConfig<TData>;\n      });\n  }, [state.visibleColumnKeys, state.columns, columnMap]);\n\n  const save = useCallback(() => {\n    if (storageKey && typeof window !== 'undefined') {\n      try {\n        localStorage.setItem(storageKey, JSON.stringify(state));\n      } catch (e) {\n        console.warn('Failed to save column config to storage:', e);\n      }\n    }\n  }, [storageKey, state]);\n\n  const load = useCallback(() => {\n    setState(getInitialState());\n  }, [getInitialState]);\n\n  // ==========================================================================\n  // RETURN\n  // ==========================================================================\n\n  const actions: ColumnConfigActions = {\n    toggleColumn,\n    setColumnVisible,\n    setColumnWidth,\n    reorderColumns,\n    moveColumn,\n    reset,\n    getVisibleColumns,\n    setSort,\n    toggleSort,\n    save,\n    load,\n  };\n\n  return { state, actions };\n}\n\nexport default useColumnConfig;\n","/**\n * @fileoverview Hook for managing row selection in tables\n * \n * Handles single and multiple row selection with keyboard support.\n * \n * @module hooks/useTableSelection\n */\n\nimport { useState, useCallback, useMemo } from 'react';\nimport type { DataRecord, SelectionConfig } from '../core/types';\nimport { getRowKey } from '../core/utils';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Selection state\n */\nexport interface TableSelectionState<T = DataRecord> {\n  /** Set of selected row keys */\n  selectedKeys: Set<string | number>;\n  /** Array of selected rows */\n  selectedRows: T[];\n  /** Whether all visible rows are selected */\n  allSelected: boolean;\n  /** Whether some (but not all) rows are selected */\n  someSelected: boolean;\n  /** Count of selected rows */\n  selectedCount: number;\n}\n\n/**\n * Selection actions\n */\nexport interface TableSelectionActions<T = DataRecord> {\n  /** Select a single row (replaces selection in single mode) */\n  select: (row: T) => void;\n  /** Deselect a row */\n  deselect: (row: T) => void;\n  /** Toggle row selection */\n  toggle: (row: T) => void;\n  /** Select all visible rows */\n  selectAll: (rows: T[]) => void;\n  /** Deselect all rows */\n  deselectAll: () => void;\n  /** Toggle select all */\n  toggleAll: (rows: T[]) => void;\n  /** Check if a row is selected */\n  isSelected: (row: T) => boolean;\n  /** Check if a row is selectable */\n  isSelectable: (row: T) => boolean;\n  /** Set selection programmatically */\n  setSelection: (rows: T[]) => void;\n  /** Clear selection */\n  clear: () => void;\n}\n\n/**\n * Options for useTableSelection hook\n */\nexport interface UseTableSelectionOptions<T = DataRecord> {\n  /** Selection configuration */\n  config?: SelectionConfig<T>;\n  /** Initial selected rows */\n  initialSelection?: T[];\n  /** Row key property */\n  rowKey?: keyof T | string;\n  /** Callback when selection changes */\n  onSelectionChange?: (selectedRows: T[]) => void;\n}\n\n// =============================================================================\n// HOOK IMPLEMENTATION\n// =============================================================================\n\n/**\n * Hook for managing table row selection\n * \n * @example\n * const { state, actions } = useTableSelection({\n *   config: { mode: 'multiple', showCheckbox: true },\n *   rowKey: 'id',\n *   onSelectionChange: (rows) => console.log('Selected:', rows),\n * });\n * \n * // Check if row is selected\n * const selected = actions.isSelected(row);\n * \n * // Toggle selection\n * actions.toggle(row);\n */\nexport function useTableSelection<T extends DataRecord = DataRecord>(\n  options: UseTableSelectionOptions<T> = {}\n): { state: TableSelectionState<T>; actions: TableSelectionActions<T> } {\n  const {\n    config = { mode: 'none' },\n    initialSelection = [],\n    rowKey = 'id',\n    onSelectionChange,\n  } = options;\n\n  // ==========================================================================\n  // STATE\n  // ==========================================================================\n\n  const [selectedMap, setSelectedMap] = useState<Map<string | number, T>>(() => {\n    const map = new Map<string | number, T>();\n    initialSelection.forEach(row => {\n      const key = getRowKey(row, rowKey);\n      map.set(key, row);\n    });\n    return map;\n  });\n\n  // ==========================================================================\n  // COMPUTED\n  // ==========================================================================\n\n  const selectedKeys = useMemo(() => {\n    return new Set(selectedMap.keys());\n  }, [selectedMap]);\n\n  const selectedRows = useMemo(() => {\n    return Array.from(selectedMap.values());\n  }, [selectedMap]);\n\n  // ==========================================================================\n  // HELPERS\n  // ==========================================================================\n\n  const getKey = useCallback((row: T): string | number => {\n    return getRowKey(row, rowKey);\n  }, [rowKey]);\n\n  const isSelectable = useCallback((row: T): boolean => {\n    if (config.mode === 'none') return false;\n    if (config.isSelectable) return config.isSelectable(row);\n    return true;\n  }, [config]);\n\n  const notifyChange = useCallback((newMap: Map<string | number, T>) => {\n    if (onSelectionChange) {\n      onSelectionChange(Array.from(newMap.values()));\n    }\n  }, [onSelectionChange]);\n\n  // ==========================================================================\n  // ACTIONS\n  // ==========================================================================\n\n  const select = useCallback((row: T) => {\n    if (!isSelectable(row)) return;\n\n    setSelectedMap(prev => {\n      const key = getKey(row);\n      \n      if (config.mode === 'single') {\n        // Single mode: replace selection\n        const newMap = new Map<string | number, T>();\n        newMap.set(key, row);\n        notifyChange(newMap);\n        return newMap;\n      } else {\n        // Multiple mode: add to selection\n        if (prev.has(key)) return prev;\n        const newMap = new Map(prev);\n        newMap.set(key, row);\n        notifyChange(newMap);\n        return newMap;\n      }\n    });\n  }, [config.mode, getKey, isSelectable, notifyChange]);\n\n  const deselect = useCallback((row: T) => {\n    setSelectedMap(prev => {\n      const key = getKey(row);\n      if (!prev.has(key)) return prev;\n      const newMap = new Map(prev);\n      newMap.delete(key);\n      notifyChange(newMap);\n      return newMap;\n    });\n  }, [getKey, notifyChange]);\n\n  const toggle = useCallback((row: T) => {\n    if (!isSelectable(row)) return;\n\n    const key = getKey(row);\n    if (selectedMap.has(key)) {\n      deselect(row);\n    } else {\n      select(row);\n    }\n  }, [getKey, selectedMap, isSelectable, select, deselect]);\n\n  const selectAll = useCallback((rows: T[]) => {\n    if (config.mode !== 'multiple') return;\n\n    setSelectedMap(prev => {\n      const newMap = new Map(prev);\n      rows.forEach(row => {\n        if (isSelectable(row)) {\n          const key = getKey(row);\n          newMap.set(key, row);\n        }\n      });\n      notifyChange(newMap);\n      return newMap;\n    });\n  }, [config.mode, getKey, isSelectable, notifyChange]);\n\n  const deselectAll = useCallback(() => {\n    setSelectedMap(prev => {\n      if (prev.size === 0) return prev;\n      const newMap = new Map<string | number, T>();\n      notifyChange(newMap);\n      return newMap;\n    });\n  }, [notifyChange]);\n\n  const toggleAll = useCallback((rows: T[]) => {\n    if (config.mode !== 'multiple') return;\n\n    const selectableRows = rows.filter(isSelectable);\n    const allSelected = selectableRows.every(row => selectedMap.has(getKey(row)));\n\n    if (allSelected) {\n      deselectAll();\n    } else {\n      selectAll(selectableRows);\n    }\n  }, [config.mode, isSelectable, selectedMap, getKey, selectAll, deselectAll]);\n\n  const isSelected = useCallback((row: T): boolean => {\n    return selectedMap.has(getKey(row));\n  }, [selectedMap, getKey]);\n\n  const setSelection = useCallback((rows: T[]) => {\n    const newMap = new Map<string | number, T>();\n    rows.forEach(row => {\n      if (isSelectable(row)) {\n        const key = getKey(row);\n        newMap.set(key, row);\n      }\n    });\n    setSelectedMap(newMap);\n    notifyChange(newMap);\n  }, [getKey, isSelectable, notifyChange]);\n\n  const clear = useCallback(() => {\n    deselectAll();\n  }, [deselectAll]);\n\n  // ==========================================================================\n  // STATE COMPUTATION\n  // ==========================================================================\n\n  const createState = useCallback((visibleRows: T[] = []): TableSelectionState<T> => {\n    const selectableRows = visibleRows.filter(isSelectable);\n    const allSelected = selectableRows.length > 0 && \n      selectableRows.every(row => selectedMap.has(getKey(row)));\n    const someSelected = !allSelected && \n      selectableRows.some(row => selectedMap.has(getKey(row)));\n\n    return {\n      selectedKeys,\n      selectedRows,\n      allSelected,\n      someSelected,\n      selectedCount: selectedMap.size,\n    };\n  }, [selectedKeys, selectedRows, selectedMap, getKey, isSelectable]);\n\n  // ==========================================================================\n  // RETURN\n  // ==========================================================================\n\n  const state = createState();\n\n  const actions: TableSelectionActions<T> = {\n    select,\n    deselect,\n    toggle,\n    selectAll,\n    deselectAll,\n    toggleAll,\n    isSelected,\n    isSelectable,\n    setSelection,\n    clear,\n  };\n\n  return { state, actions };\n}\n\nexport default useTableSelection;\n"]}