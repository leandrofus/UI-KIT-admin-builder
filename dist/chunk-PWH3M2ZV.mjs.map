{"version":3,"sources":["../src/config-system/ConfigParser.ts","../src/config-system/modalConfig.ts"],"names":[],"mappings":"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","file":"chunk-PWH3M2ZV.mjs","sourcesContent":["/**\n * @fileoverview Config Parser - Parse and normalize JSON configurations\n * \n * Provides parsing and transformation of raw JSON configs into normalized\n * structures ready for use by components.\n * \n * @module config-system/ConfigParser\n */\n\nimport type {\n  TableConfig,\n  FormConfig,\n  ColumnConfig,\n  FieldConfig,\n  FieldType,\n  FormSection,\n  ValidationRule,\n  ColumnDataType,\n  DataRecord,\n} from '../core/types';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Raw column config (from JSON)\n */\nexport interface RawColumnConfig {\n  key: string;\n  header?: string;\n  type?: string;\n  accessor?: string;\n  [key: string]: unknown;\n}\n\n/**\n * Raw field config (from JSON)\n */\nexport interface RawFieldConfig {\n  name: string;\n  type: string;\n  label?: string;\n  [key: string]: unknown;\n}\n\n/**\n * Raw section config (from JSON)\n */\nexport interface RawSectionConfig {\n  id?: string;\n  title?: string;\n  fields: RawFieldConfig[];\n  [key: string]: unknown;\n}\n\n/**\n * Raw table config (from JSON)\n */\nexport interface RawTableConfig {\n  columns: RawColumnConfig[];\n  [key: string]: unknown;\n}\n\n/**\n * Raw form config (from JSON)\n */\nexport interface RawFormConfig {\n  id?: string;\n  title?: string;\n  sections: RawSectionConfig[];\n  entity?: string;\n  [key: string]: unknown;\n}\n\n/**\n * Parser options\n */\nexport interface ParserOptions {\n  /** Default column width */\n  defaultColumnWidth?: number | string;\n  /** Default column sortable */\n  defaultSortable?: boolean;\n  /** Default field required */\n  defaultRequired?: boolean;\n  /** Field name transformer */\n  transformFieldName?: (name: string) => string;\n  /** Column key transformer */\n  transformColumnKey?: (key: string) => string;\n  /** Generate labels from names/keys */\n  generateLabels?: boolean;\n  /** Custom field normalizers */\n  fieldNormalizers?: Record<string, (field: RawFieldConfig) => Partial<FieldConfig>>;\n  /** Custom column normalizers */\n  columnNormalizers?: Record<string, (column: RawColumnConfig) => Partial<ColumnConfig>>;\n}\n\n// =============================================================================\n// HELPER FUNCTIONS\n// =============================================================================\n\n/**\n * Convert string to title case for label generation\n */\nfunction toTitleCase(str: string): string {\n  return str\n    .replace(/([A-Z])/g, ' $1') // Add space before capitals\n    .replace(/[_-]/g, ' ') // Replace underscores and dashes\n    .replace(/\\s+/g, ' ') // Normalize spaces\n    .trim()\n    .replace(/^\\w/, c => c.toUpperCase()) // Capitalize first letter\n    .replace(/\\s\\w/g, c => c.toUpperCase()); // Capitalize after spaces\n}\n\n/**\n * Deep clone an object\n */\nfunction deepClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(deepClone) as unknown as T;\n  \n  const cloned: Record<string, unknown> = {};\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      cloned[key] = deepClone((obj as Record<string, unknown>)[key]);\n    }\n  }\n  return cloned as T;\n}\n\n/**\n * Merge defaults with user config\n */\nfunction mergeDefaults<T extends object>(defaults: Partial<T>, config: T): T {\n  const result = { ...defaults } as T;\n  \n  for (const key in config) {\n    if (Object.prototype.hasOwnProperty.call(config, key)) {\n      const value = config[key];\n      if (value !== undefined) {\n        result[key] = value;\n      }\n    }\n  }\n  \n  return result;\n}\n\n// =============================================================================\n// NORMALIZATION FUNCTIONS\n// =============================================================================\n\n/**\n * Normalize a validation rule\n */\nfunction normalizeValidationRule(rule: unknown): ValidationRule | null {\n  if (!rule || typeof rule !== 'object') return null;\n  \n  const r = rule as Record<string, unknown>;\n  \n  // If it already has type, treat as structured rule\n  if ('type' in r && typeof r.type === 'string') {\n    return {\n      type: r.type as ValidationRule['type'],\n      value: r.value as string | number | RegExp | undefined,\n      message: typeof r.message === 'string' ? r.message : undefined,\n    };\n  }\n  \n  // Convert shorthand format to structured rules\n  const rules: ValidationRule[] = [];\n  \n  if ('required' in r && r.required) {\n    rules.push({ type: 'required', message: typeof r.message === 'string' ? r.message : undefined });\n  }\n  if ('min' in r && typeof r.min === 'number') {\n    rules.push({ type: 'min', value: r.min });\n  }\n  if ('max' in r && typeof r.max === 'number') {\n    rules.push({ type: 'max', value: r.max });\n  }\n  if ('minLength' in r && typeof r.minLength === 'number') {\n    rules.push({ type: 'minLength', value: r.minLength });\n  }\n  if ('maxLength' in r && typeof r.maxLength === 'number') {\n    rules.push({ type: 'maxLength', value: r.maxLength });\n  }\n  if ('pattern' in r && typeof r.pattern === 'string') {\n    rules.push({ type: 'pattern', value: r.pattern });\n  }\n  if ('email' in r && r.email) {\n    rules.push({ type: 'email' });\n  }\n  if ('url' in r && r.url) {\n    rules.push({ type: 'url' });\n  }\n\n  return rules.length > 0 ? rules[0] : null;\n}\n\n/**\n * Condition (either single or compound)\n */\ntype ConditionOrGroup = {\n  field?: string;\n  operator?: string;\n  value?: unknown;\n  logic?: 'and' | 'or';\n  conditions?: ConditionOrGroup[];\n};\n\n/**\n * Normalize a condition group\n */\nfunction normalizeConditionGroup(condition: unknown): ConditionOrGroup | undefined {\n  if (!condition || typeof condition !== 'object') return undefined;\n  \n  const c = condition as Record<string, unknown>;\n  \n  // Simple condition\n  if (c.field && typeof c.field === 'string') {\n    return {\n      field: c.field,\n      operator: typeof c.operator === 'string' ? c.operator : 'equals',\n      value: c.value,\n    };\n  }\n  \n  // Compound condition\n  if (Array.isArray(c.conditions)) {\n    return {\n      logic: (c.logic as 'and' | 'or') || 'and',\n      conditions: c.conditions\n        .map(normalizeConditionGroup)\n        .filter((cond): cond is ConditionOrGroup => cond !== undefined),\n    };\n  }\n  \n  return undefined;\n}\n\n/**\n * Normalize a field configuration\n */\nfunction normalizeField(\n  raw: RawFieldConfig, \n  options: ParserOptions\n): FieldConfig {\n  const {\n    defaultRequired = false,\n    transformFieldName,\n    generateLabels = true,\n    fieldNormalizers = {},\n  } = options;\n\n  // Start with base normalization\n  const name = transformFieldName ? transformFieldName(raw.name) : raw.name;\n  \n  const normalized: FieldConfig = {\n    name,\n    type: (raw.type || 'text') as FieldType,\n    label: (raw.label || (generateLabels ? toTitleCase(name) : name)) as string,\n    required: (raw.required as boolean | undefined) ?? defaultRequired,\n    disabled: (raw.disabled as boolean | undefined) ?? false,\n    readOnly: (raw.readOnly as boolean | undefined) ?? false,\n    placeholder: raw.placeholder as string | undefined,\n    helpText: raw.helpText as string | undefined,\n    defaultValue: raw.defaultValue as FieldConfig['defaultValue'],\n  };\n\n  // Copy optional properties\n  if (raw.options) {\n    normalized.options = deepClone(raw.options) as FieldConfig['options'];\n  }\n\n  if (raw.entityType) {\n    normalized.entityType = raw.entityType as string;\n  }\n\n  if (raw.min !== undefined) normalized.min = raw.min as number;\n  if (raw.max !== undefined) normalized.max = raw.max as number;\n  if (raw.minLength !== undefined) normalized.minLength = raw.minLength as number;\n  if (raw.maxLength !== undefined) normalized.maxLength = raw.maxLength as number;\n\n  // Normalize validation\n  if (raw.validation) {\n    if (Array.isArray(raw.validation)) {\n      normalized.validation = raw.validation\n        .map(normalizeValidationRule)\n        .filter((r): r is ValidationRule => r !== null);\n    } else {\n      const rule = normalizeValidationRule(raw.validation);\n      if (rule) normalized.validation = [rule];\n    }\n  }\n\n  // Normalize showWhen\n  if (raw.showWhen) {\n    normalized.showWhen = normalizeConditionGroup(raw.showWhen) as FieldConfig['showWhen'];\n  }\n\n  // Normalize computed\n  if (raw.computed && typeof raw.computed === 'object') {\n    const c = raw.computed as Record<string, unknown>;\n    if (typeof c.formula === 'string' && Array.isArray(c.deps)) {\n      normalized.computed = {\n        formula: c.formula,\n        deps: c.deps.filter((d): d is string => typeof d === 'string'),\n      };\n    }\n  }\n\n  // Apply custom normalizer if exists\n  if (fieldNormalizers[raw.type]) {\n    Object.assign(normalized, fieldNormalizers[raw.type](raw));\n  }\n\n  // Copy any additional properties (for extensibility)\n  const knownKeys = new Set([\n    'name', 'type', 'label', 'required', 'disabled', 'readOnly',\n    'placeholder', 'helperText', 'defaultValue', 'options', 'entityType',\n    'min', 'max', 'minLength', 'maxLength', 'validation', 'showWhen', 'computed'\n  ]);\n\n  for (const key in raw) {\n    if (!knownKeys.has(key) && raw[key] !== undefined) {\n      (normalized as unknown as Record<string, unknown>)[key] = deepClone(raw[key]);\n    }\n  }\n\n  return normalized;\n}\n\n/**\n * Normalize a form section\n */\nfunction normalizeSection(\n  raw: RawSectionConfig,\n  options: ParserOptions\n): FormSection {\n  const normalized: FormSection = {\n    id: raw.id || (raw.title?.toLowerCase().replace(/\\s+/g, '-') ?? 'section'),\n    title: raw.title ?? 'Section',\n    description: raw.description as string | undefined,\n    collapsible: (raw.collapsible as boolean | undefined) ?? false,\n    defaultCollapsed: (raw.collapsed as boolean | undefined) ?? false,\n    fields: raw.fields.map(f => normalizeField(f, options)),\n  };\n\n  if (raw.showWhen) {\n    normalized.showWhen = normalizeConditionGroup(raw.showWhen) as FormSection['showWhen'];\n  }\n\n  // Copy columns layout\n  if (raw.columns) {\n    normalized.columns = raw.columns as number;\n  }\n\n  return normalized;\n}\n\n/**\n * Normalize a column configuration\n */\nfunction normalizeColumn(\n  raw: RawColumnConfig,\n  options: ParserOptions\n): ColumnConfig {\n  const {\n    defaultColumnWidth,\n    defaultSortable = true,\n    transformColumnKey,\n    generateLabels = true,\n    columnNormalizers = {},\n  } = options;\n\n  const key = transformColumnKey ? transformColumnKey(raw.key) : raw.key;\n\n  const normalized: ColumnConfig = {\n    key,\n    accessor: raw.accessor || key,\n    header: raw.header || (generateLabels ? toTitleCase(key) : key),\n    type: (raw.type || 'text') as ColumnDataType,\n    width: (typeof raw.width === 'string' || typeof raw.width === 'number') ? raw.width : defaultColumnWidth,\n    minWidth: raw.minWidth as string | number | undefined,\n    maxWidth: raw.maxWidth as string | number | undefined,\n    sortable: (raw.sortable as boolean | undefined) ?? defaultSortable,\n    filterable: (raw.filterable as boolean | undefined) ?? false,\n    visible: raw.hidden ? false : (raw.visible as boolean | undefined) ?? true,\n    align: (raw.align as ColumnConfig['align']) || 'left',\n  };\n\n  // Copy optional properties\n  if (raw.format) normalized.format = raw.format as ColumnConfig['format'];\n  if (raw.render) normalized.render = raw.render as ColumnConfig['render'];\n\n  // Apply custom normalizer if exists\n  const type = (raw.type || (raw as any).dataType || 'text') as string;\n  if (columnNormalizers[type]) {\n    Object.assign(normalized, columnNormalizers[type](raw));\n  }\n  // If dataType was provided (legacy), ensure it maps to type for downstream components\n  normalized.type = type as any;\n\n  // Normalize showWhen\n  if (raw.showWhen) {\n    normalized.showWhen = normalizeConditionGroup(raw.showWhen) as ColumnConfig['showWhen'];\n  }\n\n  // Copy any additional properties\n  const knownKeys = new Set([\n    'key', 'header', 'type', 'width', 'minWidth', 'maxWidth',\n    'sortable', 'filterable', 'hidden', 'align', 'format',\n    'render', 'accessor', 'sortAccessor', 'filterOptions'\n  ]);\n\n  for (const k in raw) {\n    if (!knownKeys.has(k) && raw[k] !== undefined) {\n      (normalized as unknown as Record<string, unknown>)[k] = deepClone(raw[k]);\n    }\n  }\n\n  return normalized;\n}\n\n// =============================================================================\n// MAIN PARSERS\n// =============================================================================\n\n/**\n * Parse a raw table config into a normalized TableConfig\n */\nexport function parseTableConfig(\n  raw: RawTableConfig,\n  options: ParserOptions = {}\n): TableConfig {\n  const columns = raw.columns.map(c => normalizeColumn(c, options));\n\n  const config: TableConfig = {\n    columns,\n    pagination: raw.pagination as TableConfig['pagination'],\n    selection: raw.selection as TableConfig['selection'],\n    filters: raw.filters as TableConfig['filters'],\n    striped: (raw.striped as boolean | undefined),\n    bordered: (raw.bordered as boolean | undefined),\n    compact: (raw.compact as boolean | undefined),\n    hoverable: (raw.hoverable as boolean | undefined),\n    emptyMessage: raw.emptyMessage as string | undefined,\n    loadingMessage: raw.loadingMessage as string | undefined,\n    rowKey: raw.rowKey as string | undefined,\n    defaultSortColumn: raw.defaultSortColumn as string | undefined,\n    defaultSortDirection: raw.defaultSortDirection as TableConfig['defaultSortDirection'],\n  };\n\n  // Copy any additional properties\n  const knownKeys = new Set([\n    'columns', 'pagination', 'selection', 'filters',\n    'striped', 'bordered', 'compact', 'hoverable',\n    'emptyMessage', 'loadingMessage', 'rowKey',\n    'defaultSortColumn', 'defaultSortDirection'\n  ]);\n\n  for (const key in raw) {\n    if (!knownKeys.has(key) && raw[key] !== undefined) {\n      (config as unknown as Record<string, unknown>)[key] = deepClone(raw[key]);\n    }\n  }\n\n  return config;\n}\n\n/**\n * Parse a raw form config into a normalized FormConfig\n */\nexport function parseFormConfig(\n  raw: RawFormConfig,\n  options: ParserOptions = {}\n): FormConfig {\n  const sections = raw.sections.map(s => normalizeSection(s, options));\n\n  const config: FormConfig = {\n    id: raw.id || 'form',\n    title: raw.title || 'Form',\n    sections,\n    submitLabel: raw.submitLabel as string | undefined,\n    cancelLabel: raw.cancelLabel as string | undefined,\n    showCancel: (raw.showCancel as boolean | undefined),\n    size: (raw.size as FormConfig['size']),\n    validationMode: (raw.validationMode as FormConfig['validationMode']),\n  };\n\n  // Copy any additional properties\n  const knownKeys = new Set([\n    'id', 'title', 'sections', 'entity', 'submitLabel', 'cancelLabel',\n    'showCancel', 'size', 'validationMode'\n  ]);\n\n  for (const key in raw) {\n    if (!knownKeys.has(key) && raw[key] !== undefined) {\n      (config as unknown as Record<string, unknown>)[key] = deepClone(raw[key]);\n    }\n  }\n\n  return config;\n}\n\n/**\n * Parse any config (auto-detects type)\n */\nexport function parseConfig<T extends TableConfig | FormConfig>(\n  raw: RawTableConfig | RawFormConfig,\n  options: ParserOptions = {}\n): T {\n  if ('columns' in raw) {\n    return parseTableConfig(raw as RawTableConfig, options) as T;\n  }\n\n  if ('sections' in raw) {\n    return parseFormConfig(raw as RawFormConfig, options) as T;\n  }\n\n  throw new Error('Unknown config type. Must have \"columns\" (table) or \"sections\" (form)');\n}\n\n// =============================================================================\n// CONFIG LOADER\n// =============================================================================\n\n/**\n * Config loader options\n */\nexport interface ConfigLoaderOptions extends ParserOptions {\n  /** Base path for config files */\n  basePath?: string;\n  /** Cache loaded configs */\n  cache?: boolean;\n  /** Validate on load */\n  validate?: boolean;\n}\n\n/**\n * Config loader for dynamically loading JSON configs\n */\nexport class ConfigLoader {\n  private cache: Map<string, TableConfig | FormConfig> = new Map();\n  private options: ConfigLoaderOptions;\n\n  constructor(options: ConfigLoaderOptions = {}) {\n    this.options = {\n      basePath: '/configs',\n      cache: true,\n      validate: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Load a config from URL or path\n   */\n  async load<T extends TableConfig | FormConfig>(path: string): Promise<T> {\n    // Check cache\n    if (this.options.cache && this.cache.has(path)) {\n      return this.cache.get(path) as T;\n    }\n\n    // Build full URL\n    const url = path.startsWith('http') \n      ? path \n      : `${this.options.basePath}/${path}`;\n\n    try {\n      const response = await fetch(url);\n      \n      if (!response.ok) {\n        throw new Error(`Failed to load config: ${response.statusText}`);\n      }\n\n      const raw = await response.json();\n      const parsed = parseConfig<T>(raw, this.options);\n\n      // Cache result\n      if (this.options.cache) {\n        this.cache.set(path, parsed);\n      }\n\n      return parsed;\n    } catch (error) {\n      throw new Error(`Failed to load config from ${path}: ${error}`);\n    }\n  }\n\n  /**\n   * Load multiple configs\n   */\n  async loadMany<T extends TableConfig | FormConfig>(paths: string[]): Promise<T[]> {\n    return Promise.all(paths.map(path => this.load<T>(path)));\n  }\n\n  /**\n   * Clear the cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Remove a specific config from cache\n   */\n  invalidate(path: string): void {\n    this.cache.delete(path);\n  }\n}\n\n/**\n * Create a config loader instance\n */\nexport function createConfigLoader(options?: ConfigLoaderOptions): ConfigLoader {\n  return new ConfigLoader(options);\n}\n\nexport default parseConfig;\n","/**\n * @fileoverview Modal config - Canonical modal config format and parsing\n *\n * Defines the canonical \"modal config\" format (title by mode, sections, footer labels)\n * and parseModalConfig(raw, mode) that returns a resolved config for DynamicModal.\n *\n * @module config-system/modalConfig\n */\n\nimport type { ModalMode } from '../core/types';\nimport type { FormConfig } from '../core/types';\nimport {\n  parseFormConfig,\n  type RawFormConfig,\n  type RawSectionConfig,\n  type RawFieldConfig,\n  type ParserOptions,\n} from './ConfigParser';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/** Title or submit label: single string or per-mode */\nexport type TitleOrLabelByMode =\n  | string\n  | { create?: string; edit?: string; view?: string };\n\n/** Raw modal config (JSON shape) - extends form with title/labels by mode */\nexport interface RawModalConfig extends Omit<RawFormConfig, 'title'> {\n  id: string;\n  /** Title: string or per mode (create, edit, view) */\n  title: string | { create?: string; edit?: string; view?: string };\n  subtitle?: string;\n  icon?: string;\n  size?: 'sm' | 'md' | 'lg' | 'xl' | 'full';\n  showCloseButton?: boolean;\n  closeOnEscape?: boolean;\n  closeOnBackdrop?: boolean;\n  /** Flat fields (no sections) - will be wrapped in a default section */\n  fields?: RawFieldConfig[];\n  sections?: RawSectionConfig[];\n  columns?: number;\n  footer?: {\n    submitLabel?: TitleOrLabelByMode;\n    cancelLabel?: string;\n    resetLabel?: string;\n    align?: 'left' | 'center' | 'right' | 'between';\n  };\n  [key: string]: unknown;\n}\n\n/** Result of parseModalConfig: form config plus resolved title/labels for the given mode */\nexport interface ParsedModalConfig {\n  formConfig: FormConfig;\n  title: string;\n  submitLabel: string;\n  cancelLabel?: string;\n  size?: RawModalConfig['size'];\n  subtitle?: string;\n  icon?: string;\n  showCloseButton?: boolean;\n  closeOnEscape?: boolean;\n  closeOnBackdrop?: boolean;\n}\n\n// =============================================================================\n// HELPERS\n// =============================================================================\n\n/**\n * Resolves title for the given mode (string or record by mode).\n */\nexport function getModalTitle(\n  title: TitleOrLabelByMode | undefined,\n  mode: ModalMode\n): string {\n  if (title == null) return '';\n  if (typeof title === 'string') return title;\n  return title[mode] ?? title.edit ?? title.create ?? title.view ?? '';\n}\n\n/**\n * Resolves submit button label for the given mode.\n */\nexport function getModalSubmitLabel(\n  submitLabel: TitleOrLabelByMode | undefined,\n  mode: ModalMode\n): string {\n  if (submitLabel == null) {\n    return mode === 'create' ? 'Create' : mode === 'edit' ? 'Save' : 'Close';\n  }\n  if (typeof submitLabel === 'string') return submitLabel;\n  return submitLabel[mode] ?? submitLabel.edit ?? submitLabel.create ?? 'Save';\n}\n\n// =============================================================================\n// PARSER\n// =============================================================================\n\n/**\n * Parses raw modal JSON into a resolved config for the given mode.\n * - Normalizes sections (or flat fields) into FormConfig via parseFormConfig.\n * - Resolves title and submitLabel for the given mode.\n * Use translateConfig(raw) before calling if the JSON contains i18n keys.\n */\nexport function parseModalConfig(\n  raw: RawModalConfig,\n  mode: ModalMode,\n  options: ParserOptions = {}\n): ParsedModalConfig {\n  // Build RawFormConfig: ensure sections array (wrap flat fields if needed)\n  const rawForm: RawFormConfig = {\n    id: raw.id,\n    title: getModalTitle(raw.title, mode),\n    sections:\n      raw.sections && raw.sections.length > 0\n        ? raw.sections\n        : raw.fields && raw.fields.length > 0\n          ? [\n              {\n                id: 'default',\n                title: '',\n                columns: raw.columns ?? 2,\n                fields: raw.fields,\n              },\n            ]\n          : [],\n  };\n\n  const formConfig = parseFormConfig(rawForm, options);\n\n  return {\n    formConfig,\n    title: getModalTitle(raw.title, mode),\n    submitLabel: getModalSubmitLabel(raw.footer?.submitLabel, mode),\n    cancelLabel: raw.footer?.cancelLabel,\n    size: raw.size,\n    subtitle: raw.subtitle,\n    icon: raw.icon,\n    showCloseButton: raw.showCloseButton,\n    closeOnEscape: raw.closeOnEscape,\n    closeOnBackdrop: raw.closeOnBackdrop,\n  };\n}\n"]}