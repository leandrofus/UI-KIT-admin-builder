{"version":3,"sources":["../src/config-system/ConfigValidator.ts","../src/config-system/translateConfig.ts"],"names":[],"mappings":"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","file":"chunk-7N5OT25E.mjs","sourcesContent":["/**\n * @fileoverview Config Validator - Validates JSON configuration schemas\n * \n * Provides comprehensive validation for table and form configurations,\n * with helpful error messages for debugging.\n * \n * @module config-system/ConfigValidator\n */\n\nimport type {\n  TableConfig,\n  FormConfig,\n  ColumnConfig,\n  FieldConfig,\n  FormSection,\n  ValidationRule,\n  FieldCondition,\n  DataRecord,\n} from '../core/types';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Validation error details\n */\nexport interface ValidationError {\n  /** Path to the invalid property */\n  path: string;\n  /** Error message */\n  message: string;\n  /** Suggested fix */\n  suggestion?: string;\n  /** Severity level */\n  severity: 'error' | 'warning';\n}\n\n/**\n * Validation result\n */\nexport interface ValidationResult {\n  /** Whether validation passed (no errors) */\n  valid: boolean;\n  /** List of validation errors */\n  errors: ValidationError[];\n  /** List of warnings */\n  warnings: ValidationError[];\n}\n\n/**\n * Validator options\n */\nexport interface ValidatorOptions {\n  /** Strict mode (treat warnings as errors) */\n  strict?: boolean;\n  /** Known field types (for type validation) */\n  knownFieldTypes?: string[];\n  /** Known column types */\n  knownColumnTypes?: string[];\n  /** Custom validators */\n  customValidators?: Record<string, (value: unknown, path: string) => ValidationError[]>;\n}\n\n// =============================================================================\n// DEFAULT OPTIONS\n// =============================================================================\n\nconst DEFAULT_FIELD_TYPES = [\n  'text', 'number', 'email', 'password', 'tel', 'url',\n  'textarea', 'select', 'multiselect', 'checkbox', 'radio',\n  'switch', 'date', 'datetime', 'time', 'file', 'image',\n  'currency', 'percent', 'hidden', 'entity', 'generic',\n];\n\nconst DEFAULT_COLUMN_TYPES = [\n  'text', 'number', 'currency', 'percent', 'date', 'datetime',\n  'boolean', 'badge', 'link', 'image', 'actions', 'custom',\n];\n\n// =============================================================================\n// HELPER FUNCTIONS\n// =============================================================================\n\nfunction createError(\n  path: string,\n  message: string,\n  severity: 'error' | 'warning' = 'error',\n  suggestion?: string\n): ValidationError {\n  return { path, message, severity, suggestion };\n}\n\nfunction isNonEmptyString(value: unknown): value is string {\n  return typeof value === 'string' && value.trim().length > 0;\n}\n\nfunction isValidArray(value: unknown): value is unknown[] {\n  return Array.isArray(value);\n}\n\nfunction isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\n// =============================================================================\n// VALIDATION FUNCTIONS\n// =============================================================================\n\n/**\n * Validate a validation rule configuration\n */\nfunction validateValidationRule(\n  rule: unknown,\n  path: string\n): ValidationError[] {\n  const errors: ValidationError[] = [];\n\n  if (!isObject(rule)) {\n    errors.push(createError(path, 'Validation rule must be an object'));\n    return errors;\n  }\n\n  const r = rule as Record<string, unknown>;\n\n  // Check for known rule types\n  const knownRules = [\n    'required', 'min', 'max', 'minLength', 'maxLength',\n    'pattern', 'email', 'url', 'custom', 'match'\n  ];\n\n  const hasKnownRule = knownRules.some(k => k in r);\n  if (!hasKnownRule) {\n    errors.push(createError(\n      path,\n      'Validation rule has no known validation type',\n      'warning',\n      `Add one of: ${knownRules.join(', ')}`\n    ));\n  }\n\n  // Validate specific rules\n  if ('min' in r && typeof r.min !== 'number') {\n    errors.push(createError(`${path}.min`, 'min must be a number'));\n  }\n\n  if ('max' in r && typeof r.max !== 'number') {\n    errors.push(createError(`${path}.max`, 'max must be a number'));\n  }\n\n  if ('minLength' in r && typeof r.minLength !== 'number') {\n    errors.push(createError(`${path}.minLength`, 'minLength must be a number'));\n  }\n\n  if ('maxLength' in r && typeof r.maxLength !== 'number') {\n    errors.push(createError(`${path}.maxLength`, 'maxLength must be a number'));\n  }\n\n  if ('pattern' in r && typeof r.pattern !== 'string') {\n    errors.push(createError(`${path}.pattern`, 'pattern must be a string (regex)'));\n  }\n\n  if ('custom' in r && typeof r.custom !== 'function') {\n    errors.push(createError(\n      `${path}.custom`,\n      'custom must be a function',\n      'warning',\n      'Custom validators in JSON configs will be ignored'\n    ));\n  }\n\n  return errors;\n}\n\n/**\n * Validate condition group\n */\nfunction validateConditionGroup(\n  condition: unknown,\n  path: string\n): ValidationError[] {\n  const errors: ValidationError[] = [];\n\n  if (!isObject(condition)) {\n    errors.push(createError(path, 'Condition must be an object'));\n    return errors;\n  }\n\n  const c = condition as unknown as FieldCondition & {\n    conditions?: FieldCondition[];\n    logic?: 'and' | 'or';\n  };\n\n  if (!c.field && !c.conditions) {\n    errors.push(createError(\n      path,\n      'Condition must have either \"field\" or \"conditions\"',\n      'error',\n      'For single condition: { field: \"status\", operator: \"eq\", value: \"active\" }'\n    ));\n  }\n\n  if (c.field) {\n    if (!isNonEmptyString(c.field)) {\n      errors.push(createError(`${path}.field`, 'field must be a non-empty string'));\n    }\n\n    if (!c.operator) {\n      errors.push(createError(`${path}.operator`, 'operator is required'));\n    } else {\n      const validOperators = ['eq', 'neq', 'gt', 'gte', 'lt', 'lte', 'in', 'notIn', 'contains', 'startsWith', 'endsWith', 'empty', 'notEmpty'];\n      if (!validOperators.includes(c.operator)) {\n        errors.push(createError(\n          `${path}.operator`,\n          `Invalid operator: ${c.operator}`,\n          'error',\n          `Valid operators: ${validOperators.join(', ')}`\n        ));\n      }\n    }\n  }\n\n  if (c.conditions) {\n    if (!isValidArray(c.conditions)) {\n      errors.push(createError(`${path}.conditions`, 'conditions must be an array'));\n    } else {\n      (c.conditions as unknown[]).forEach((sub: unknown, i: number) => {\n        errors.push(...validateConditionGroup(sub, `${path}.conditions[${i}]`));\n      });\n    }\n\n    if (c.logic && !['and', 'or'].includes(c.logic)) {\n      errors.push(createError(\n        `${path}.logic`,\n        'logic must be \"and\" or \"or\"',\n        'error'\n      ));\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Validate a field configuration\n */\nfunction validateFieldConfig(\n  field: unknown,\n  path: string,\n  options: ValidatorOptions\n): ValidationError[] {\n  const errors: ValidationError[] = [];\n  const knownTypes = options.knownFieldTypes || DEFAULT_FIELD_TYPES;\n\n  if (!isObject(field)) {\n    errors.push(createError(path, 'Field configuration must be an object'));\n    return errors;\n  }\n\n  const f = field as unknown as FieldConfig;\n\n  // Required fields\n  if (!isNonEmptyString(f.name)) {\n    errors.push(createError(`${path}.name`, 'name is required and must be a non-empty string'));\n  }\n\n  if (!isNonEmptyString(f.type)) {\n    errors.push(createError(`${path}.type`, 'type is required'));\n  } else if (!knownTypes.includes(f.type) && f.type !== 'generic') {\n    errors.push(createError(\n      `${path}.type`,\n      `Unknown field type: ${f.type}`,\n      'warning',\n      `Known types: ${knownTypes.join(', ')}. Use \"generic\" for custom types.`\n    ));\n  }\n\n  // Label recommendation\n  if (!f.label) {\n    errors.push(createError(\n      `${path}.label`,\n      'label is recommended for accessibility',\n      'warning'\n    ));\n  }\n\n  // Validate options for select fields\n  if (['select', 'multiselect', 'radio'].includes(f.type)) {\n    if (!f.options && !f.entityType) {\n      errors.push(createError(\n        `${path}.options`,\n        `${f.type} field requires options or entityType`,\n        'error'\n      ));\n    }\n  }\n\n  // Validate validation rules\n  if (f.validation) {\n    if (isValidArray(f.validation)) {\n      f.validation.forEach((rule, i) => {\n        errors.push(...validateValidationRule(rule, `${path}.validation[${i}]`));\n      });\n    } else if (isObject(f.validation)) {\n      errors.push(...validateValidationRule(f.validation, `${path}.validation`));\n    }\n  }\n\n  // Validate showWhen\n  if (f.showWhen) {\n    errors.push(...validateConditionGroup(f.showWhen, `${path}.showWhen`));\n  }\n\n  // Validate computed fields\n  if (f.computed) {\n    if (!isObject(f.computed)) {\n      errors.push(createError(`${path}.computed`, 'computed must be an object'));\n    } else {\n      const c = f.computed as Record<string, unknown>;\n      if (!isNonEmptyString(c.formula)) {\n        errors.push(createError(`${path}.computed.formula`, 'computed.formula is required'));\n      }\n      if (!isValidArray(c.deps)) {\n        errors.push(createError(`${path}.computed.deps`, 'computed.deps must be an array of field names'));\n      }\n    }\n  }\n\n  // Validate format options\n  if (f.format) {\n    if (!isObject(f.format)) {\n      errors.push(createError(`${path}.format`, 'format must be an object'));\n    } else {\n      const fmt = f.format as Record<string, unknown>;\n      if (fmt.toFixed !== undefined) {\n        if (!Number.isInteger(fmt.toFixed) || (fmt.toFixed as number) < 0) {\n          errors.push(createError(`${path}.format.toFixed`, 'format.toFixed must be an integer >= 0'));\n        }\n      }\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Validate a form section\n */\nfunction validateFormSection(\n  section: unknown,\n  path: string,\n  options: ValidatorOptions\n): ValidationError[] {\n  const errors: ValidationError[] = [];\n\n  if (!isObject(section)) {\n    errors.push(createError(path, 'Section must be an object'));\n    return errors;\n  }\n\n  const s = section as unknown as FormSection;\n\n  // Validate fields\n  if (!isValidArray(s.fields)) {\n    errors.push(createError(`${path}.fields`, 'fields is required and must be an array'));\n  } else if (s.fields.length === 0) {\n    errors.push(createError(`${path}.fields`, 'fields array is empty', 'warning'));\n  } else {\n    s.fields.forEach((field, i) => {\n      errors.push(...validateFieldConfig(field, `${path}.fields[${i}]`, options));\n    });\n  }\n\n  // Validate showWhen\n  if (s.showWhen) {\n    errors.push(...validateConditionGroup(s.showWhen, `${path}.showWhen`));\n  }\n\n  return errors;\n}\n\n/**\n * Validate a column configuration\n */\nfunction validateColumnConfig(\n  column: unknown,\n  path: string,\n  options: ValidatorOptions\n): ValidationError[] {\n  const errors: ValidationError[] = [];\n  const knownTypes = options.knownColumnTypes || DEFAULT_COLUMN_TYPES;\n\n  if (!isObject(column)) {\n    errors.push(createError(path, 'Column configuration must be an object'));\n    return errors;\n  }\n\n  const c = column as unknown as ColumnConfig;\n\n  // Required fields\n  if (!isNonEmptyString(c.key)) {\n    errors.push(createError(`${path}.key`, 'key is required and must be a non-empty string'));\n  }\n\n  if (!isNonEmptyString(c.header)) {\n    errors.push(createError(\n      `${path}.header`,\n      'header is recommended',\n      'warning',\n      'Will display column key if header is not provided'\n    ));\n  }\n\n  // Validate type\n  if (c.type && !knownTypes.includes(c.type) && c.type !== 'custom') {\n    errors.push(createError(\n      `${path}.type`,\n      `Unknown column type: ${c.type}`,\n      'warning',\n      `Known types: ${knownTypes.join(', ')}`\n    ));\n  }\n\n  // Validate width\n  if (c.width !== undefined && typeof c.width !== 'number' && typeof c.width !== 'string') {\n    errors.push(createError(`${path}.width`, 'width must be a number or string'));\n  }\n\n  return errors;\n}\n\n// =============================================================================\n// MAIN VALIDATORS\n// =============================================================================\n\n/**\n * Validate a TableConfig\n */\nexport function validateTableConfig(\n  config: unknown,\n  options: ValidatorOptions = {}\n): ValidationResult {\n  const errors: ValidationError[] = [];\n\n  if (!isObject(config)) {\n    return {\n      valid: false,\n      errors: [createError('', 'Table config must be an object')],\n      warnings: [],\n    };\n  }\n\n  const c = config as unknown as TableConfig;\n\n  // Validate columns\n  if (!isValidArray(c.columns)) {\n    errors.push(createError('columns', 'columns is required and must be an array'));\n  } else if (c.columns.length === 0) {\n    errors.push(createError('columns', 'columns array is empty'));\n  } else {\n    c.columns.forEach((col, i) => {\n      errors.push(...validateColumnConfig(col, `columns[${i}]`, options));\n    });\n\n    // Check for duplicate keys\n    const keys = c.columns.map(col => col.key);\n    const duplicates = keys.filter((k, i) => keys.indexOf(k) !== i);\n    if (duplicates.length > 0) {\n      errors.push(createError(\n        'columns',\n        `Duplicate column keys: ${[...new Set(duplicates)].join(', ')}`,\n        'error'\n      ));\n    }\n  }\n\n  // Validate pagination\n  if (c.pagination !== undefined && typeof c.pagination !== 'boolean') {\n    if (isObject(c.pagination)) {\n      const p = c.pagination as Record<string, unknown>;\n      if (p.pageSize && typeof p.pageSize !== 'number') {\n        errors.push(createError('pagination.pageSize', 'pageSize must be a number'));\n      }\n    } else {\n      errors.push(createError('pagination', 'pagination must be boolean or object'));\n    }\n  }\n\n  // Apply custom validators\n  if (options.customValidators) {\n    for (const [key, validator] of Object.entries(options.customValidators)) {\n      const configObj = c as unknown as Record<string, unknown>;\n      if (key in configObj) {\n        errors.push(...validator(configObj[key], key));\n      }\n    }\n  }\n\n  // Separate errors and warnings\n  const actualErrors = errors.filter(e => e.severity === 'error');\n  const warnings = errors.filter(e => e.severity === 'warning');\n\n  return {\n    valid: options.strict ? errors.length === 0 : actualErrors.length === 0,\n    errors: actualErrors,\n    warnings,\n  };\n}\n\n/**\n * Validate a FormConfig\n */\nexport function validateFormConfig(\n  config: unknown,\n  options: ValidatorOptions = {}\n): ValidationResult {\n  const errors: ValidationError[] = [];\n\n  if (!isObject(config)) {\n    return {\n      valid: false,\n      errors: [createError('', 'Form config must be an object')],\n      warnings: [],\n    };\n  }\n\n  const c = config as unknown as FormConfig;\n\n  // Validate sections\n  if (!isValidArray(c.sections)) {\n    errors.push(createError('sections', 'sections is required and must be an array'));\n  } else if (c.sections.length === 0) {\n    errors.push(createError('sections', 'sections array is empty'));\n  } else {\n    c.sections.forEach((section, i) => {\n      errors.push(...validateFormSection(section, `sections[${i}]`, options));\n    });\n  }\n\n  // Check for duplicate field names\n  const allFields = c.sections?.flatMap(s => s.fields) || [];\n  const names = allFields.map(f => f.name);\n  const duplicates = names.filter((n, i) => names.indexOf(n) !== i);\n  if (duplicates.length > 0) {\n    errors.push(createError(\n      'sections',\n      `Duplicate field names: ${[...new Set(duplicates)].join(', ')}`,\n      'error'\n    ));\n  }\n\n  // Validate id\n  if (!isNonEmptyString(c.id)) {\n    errors.push(createError('id', 'id is recommended', 'warning'));\n  }\n\n  // Apply custom validators\n  if (options.customValidators) {\n    for (const [key, validator] of Object.entries(options.customValidators)) {\n      const configObj = c as unknown as Record<string, unknown>;\n      if (key in configObj) {\n        errors.push(...validator(configObj[key], key));\n      }\n    }\n  }\n\n  // Separate errors and warnings\n  const actualErrors = errors.filter(e => e.severity === 'error');\n  const warnings = errors.filter(e => e.severity === 'warning');\n\n  return {\n    valid: options.strict ? errors.length === 0 : actualErrors.length === 0,\n    errors: actualErrors,\n    warnings,\n  };\n}\n\n/**\n * Validate any config (auto-detects type)\n */\nexport function validateConfig(\n  config: unknown,\n  options: ValidatorOptions = {}\n): ValidationResult {\n  if (!isObject(config)) {\n    return {\n      valid: false,\n      errors: [createError('', 'Config must be an object')],\n      warnings: [],\n    };\n  }\n\n  const c = config as Record<string, unknown>;\n\n  // Detect type\n  if ('columns' in c) {\n    return validateTableConfig(config, options);\n  }\n\n  if ('sections' in c) {\n    return validateFormConfig(config, options);\n  }\n\n  return {\n    valid: false,\n    errors: [createError('', 'Unknown config type. Must have \"columns\" (table) or \"sections\" (form)')],\n    warnings: [],\n  };\n}\n\n// =============================================================================\n// UTILITY FUNCTIONS\n// =============================================================================\n\n/**\n * Format validation errors for display\n */\nexport function formatValidationErrors(result: ValidationResult): string {\n  const lines: string[] = [];\n\n  if (result.errors.length > 0) {\n    lines.push('Errors:');\n    result.errors.forEach(e => {\n      lines.push(`  ✗ ${e.path || 'root'}: ${e.message}`);\n      if (e.suggestion) {\n        lines.push(`    → ${e.suggestion}`);\n      }\n    });\n  }\n\n  if (result.warnings.length > 0) {\n    lines.push('Warnings:');\n    result.warnings.forEach(w => {\n      lines.push(`  ⚠ ${w.path || 'root'}: ${w.message}`);\n      if (w.suggestion) {\n        lines.push(`    → ${w.suggestion}`);\n      }\n    });\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Assert config is valid (throws on error)\n */\nexport function assertValidConfig(\n  config: unknown,\n  options: ValidatorOptions = {}\n): void {\n  const result = validateConfig(config, options);\n\n  if (!result.valid) {\n    throw new Error(`Invalid configuration:\\n${formatValidationErrors(result)}`);\n  }\n}\n\nexport default validateConfig;\n","/**\n * @fileoverview Translate config - Resolve i18n keys in JSON configs\n *\n * Walks any config object and replaces string values that look like i18n keys\n * with the translated value using the library's I18n (or a provided instance).\n *\n * @module config-system/translateConfig\n */\n\nimport { getI18n } from '../i18n/I18n';\n\n/** i18n interface used for translation (t and optional resolveLabel) */\nexport interface I18nLike {\n  t: (key: string, params?: Record<string, string | number>, fallback?: string) => string;\n  resolveLabel?: (key: string, fallback?: string) => string;\n}\n\n/**\n * Heuristic: determines if a string looks like an i18n key (e.g. 'product.modal.create').\n * - Contains at least one dot\n * - Only letters, numbers, underscore, dash and dots\n * - No spaces\n */\nexport function isLikelyTranslationKey(s: string): boolean {\n  if (typeof s !== 'string') return false;\n  if (s.indexOf(' ') !== -1) return false;\n  return /[.]/.test(s) && /^[A-Za-z0-9._-]+$/.test(s);\n}\n\n/**\n * Recursively translates all string values in a config that look like i18n keys.\n * Uses the provided i18n instance or the library's getI18n().\n * Does not mutate the original object; returns a deep copy with translated strings.\n */\nexport function translateConfig<T>(\n  obj: T,\n  i18nInstance?: I18nLike\n): T {\n  const i18n = i18nInstance ?? (getI18n() as I18nLike);\n\n  function rec(value: unknown): unknown {\n    if (Array.isArray(value)) return value.map(rec);\n    if (value !== null && typeof value === 'object') {\n      const out: Record<string, unknown> = {};\n      for (const k of Object.keys(value as Record<string, unknown>)) {\n        out[k] = rec((value as Record<string, unknown>)[k]);\n      }\n      return out;\n    }\n    if (typeof value === 'string') {\n      if (isLikelyTranslationKey(value)) {\n        const translated = i18n.t(value);\n        if (translated && translated !== value) return translated;\n        return i18n.resolveLabel ? i18n.resolveLabel(value, value) : value;\n      }\n      return value;\n    }\n    return value;\n  }\n\n  return rec(obj) as T;\n}\n"]}