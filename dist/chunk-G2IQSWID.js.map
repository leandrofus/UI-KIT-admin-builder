{"version":3,"sources":["../src/config-system/ConfigValidator.ts","../src/config-system/ConfigParser.ts"],"names":[],"mappings":";;;AAoEA,IAAM,mBAAA,GAAsB;AAAA,EAC1B,MAAA;AAAA,EAAQ,QAAA;AAAA,EAAU,OAAA;AAAA,EAAS,UAAA;AAAA,EAAY,KAAA;AAAA,EAAO,KAAA;AAAA,EAC9C,UAAA;AAAA,EAAY,QAAA;AAAA,EAAU,aAAA;AAAA,EAAe,UAAA;AAAA,EAAY,OAAA;AAAA,EACjD,QAAA;AAAA,EAAU,MAAA;AAAA,EAAQ,UAAA;AAAA,EAAY,MAAA;AAAA,EAAQ,MAAA;AAAA,EAAQ,OAAA;AAAA,EAC9C,UAAA;AAAA,EAAY,SAAA;AAAA,EAAW,QAAA;AAAA,EAAU,QAAA;AAAA,EAAU;AAC7C,CAAA;AAEA,IAAM,oBAAA,GAAuB;AAAA,EAC3B,MAAA;AAAA,EAAQ,QAAA;AAAA,EAAU,UAAA;AAAA,EAAY,SAAA;AAAA,EAAW,MAAA;AAAA,EAAQ,UAAA;AAAA,EACjD,SAAA;AAAA,EAAW,OAAA;AAAA,EAAS,MAAA;AAAA,EAAQ,OAAA;AAAA,EAAS,SAAA;AAAA,EAAW;AAClD,CAAA;AAMA,SAAS,WAAA,CACP,IAAA,EACA,OAAA,EACA,QAAA,GAAgC,SAChC,UAAA,EACiB;AACjB,EAAA,OAAO,EAAE,IAAA,EAAM,OAAA,EAAS,QAAA,EAAU,UAAA,EAAW;AAC/C;AAEA,SAAS,iBAAiB,KAAA,EAAiC;AACzD,EAAA,OAAO,OAAO,KAAA,KAAU,QAAA,IAAY,KAAA,CAAM,IAAA,GAAO,MAAA,GAAS,CAAA;AAC5D;AAEA,SAAS,aAAa,KAAA,EAAoC;AACxD,EAAA,OAAO,KAAA,CAAM,QAAQ,KAAK,CAAA;AAC5B;AAEA,SAAS,SAAS,KAAA,EAAkD;AAClE,EAAA,OAAO,OAAO,UAAU,QAAA,IAAY,KAAA,KAAU,QAAQ,CAAC,KAAA,CAAM,QAAQ,KAAK,CAAA;AAC5E;AASA,SAAS,sBAAA,CACP,MACA,IAAA,EACmB;AACnB,EAAA,MAAM,SAA4B,EAAC;AAEnC,EAAA,IAAI,CAAC,QAAA,CAAS,IAAI,CAAA,EAAG;AACnB,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA,CAAY,IAAA,EAAM,mCAAmC,CAAC,CAAA;AAClE,IAAA,OAAO,MAAA;AAAA,EACT;AAEA,EAAA,MAAM,CAAA,GAAI,IAAA;AAGV,EAAA,MAAM,UAAA,GAAa;AAAA,IACjB,UAAA;AAAA,IAAY,KAAA;AAAA,IAAO,KAAA;AAAA,IAAO,WAAA;AAAA,IAAa,WAAA;AAAA,IACvC,SAAA;AAAA,IAAW,OAAA;AAAA,IAAS,KAAA;AAAA,IAAO,QAAA;AAAA,IAAU;AAAA,GACvC;AAEA,EAAA,MAAM,YAAA,GAAe,UAAA,CAAW,IAAA,CAAK,CAAA,CAAA,KAAK,KAAK,CAAC,CAAA;AAChD,EAAA,IAAI,CAAC,YAAA,EAAc;AACjB,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA;AAAA,MACV,IAAA;AAAA,MACA,8CAAA;AAAA,MACA,SAAA;AAAA,MACA,CAAA,YAAA,EAAe,UAAA,CAAW,IAAA,CAAK,IAAI,CAAC,CAAA;AAAA,KACrC,CAAA;AAAA,EACH;AAGA,EAAA,IAAI,KAAA,IAAS,CAAA,IAAK,OAAO,CAAA,CAAE,QAAQ,QAAA,EAAU;AAC3C,IAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,IAAA,CAAA,EAAQ,sBAAsB,CAAC,CAAA;AAAA,EAChE;AAEA,EAAA,IAAI,KAAA,IAAS,CAAA,IAAK,OAAO,CAAA,CAAE,QAAQ,QAAA,EAAU;AAC3C,IAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,IAAA,CAAA,EAAQ,sBAAsB,CAAC,CAAA;AAAA,EAChE;AAEA,EAAA,IAAI,WAAA,IAAe,CAAA,IAAK,OAAO,CAAA,CAAE,cAAc,QAAA,EAAU;AACvD,IAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,UAAA,CAAA,EAAc,4BAA4B,CAAC,CAAA;AAAA,EAC5E;AAEA,EAAA,IAAI,WAAA,IAAe,CAAA,IAAK,OAAO,CAAA,CAAE,cAAc,QAAA,EAAU;AACvD,IAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,UAAA,CAAA,EAAc,4BAA4B,CAAC,CAAA;AAAA,EAC5E;AAEA,EAAA,IAAI,SAAA,IAAa,CAAA,IAAK,OAAO,CAAA,CAAE,YAAY,QAAA,EAAU;AACnD,IAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,QAAA,CAAA,EAAY,kCAAkC,CAAC,CAAA;AAAA,EAChF;AAEA,EAAA,IAAI,QAAA,IAAY,CAAA,IAAK,OAAO,CAAA,CAAE,WAAW,UAAA,EAAY;AACnD,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA;AAAA,MACV,GAAG,IAAI,CAAA,OAAA,CAAA;AAAA,MACP,2BAAA;AAAA,MACA,SAAA;AAAA,MACA;AAAA,KACD,CAAA;AAAA,EACH;AAEA,EAAA,OAAO,MAAA;AACT;AAKA,SAAS,sBAAA,CACP,WACA,IAAA,EACmB;AACnB,EAAA,MAAM,SAA4B,EAAC;AAEnC,EAAA,IAAI,CAAC,QAAA,CAAS,SAAS,CAAA,EAAG;AACxB,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA,CAAY,IAAA,EAAM,6BAA6B,CAAC,CAAA;AAC5D,IAAA,OAAO,MAAA;AAAA,EACT;AAEA,EAAA,MAAM,CAAA,GAAI,SAAA;AAKV,EAAA,IAAI,CAAC,CAAA,CAAE,KAAA,IAAS,CAAC,EAAE,UAAA,EAAY;AAC7B,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA;AAAA,MACV,IAAA;AAAA,MACA,oDAAA;AAAA,MACA,OAAA;AAAA,MACA;AAAA,KACD,CAAA;AAAA,EACH;AAEA,EAAA,IAAI,EAAE,KAAA,EAAO;AACX,IAAA,IAAI,CAAC,gBAAA,CAAiB,CAAA,CAAE,KAAK,CAAA,EAAG;AAC9B,MAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,MAAA,CAAA,EAAU,kCAAkC,CAAC,CAAA;AAAA,IAC9E;AAEA,IAAA,IAAI,CAAC,EAAE,QAAA,EAAU;AACf,MAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,SAAA,CAAA,EAAa,sBAAsB,CAAC,CAAA;AAAA,IACrE,CAAA,MAAO;AACL,MAAA,MAAM,cAAA,GAAiB,CAAC,IAAA,EAAM,KAAA,EAAO,MAAM,KAAA,EAAO,IAAA,EAAM,KAAA,EAAO,IAAA,EAAM,OAAA,EAAS,UAAA,EAAY,YAAA,EAAc,UAAA,EAAY,SAAS,UAAU,CAAA;AACvI,MAAA,IAAI,CAAC,cAAA,CAAe,QAAA,CAAS,CAAA,CAAE,QAAQ,CAAA,EAAG;AACxC,QAAA,MAAA,CAAO,IAAA,CAAK,WAAA;AAAA,UACV,GAAG,IAAI,CAAA,SAAA,CAAA;AAAA,UACP,CAAA,kBAAA,EAAqB,EAAE,QAAQ,CAAA,CAAA;AAAA,UAC/B,OAAA;AAAA,UACA,CAAA,iBAAA,EAAoB,cAAA,CAAe,IAAA,CAAK,IAAI,CAAC,CAAA;AAAA,SAC9C,CAAA;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAEA,EAAA,IAAI,EAAE,UAAA,EAAY;AAChB,IAAA,IAAI,CAAC,YAAA,CAAa,CAAA,CAAE,UAAU,CAAA,EAAG;AAC/B,MAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,WAAA,CAAA,EAAe,6BAA6B,CAAC,CAAA;AAAA,IAC9E,CAAA,MAAO;AACL,MAAC,CAAA,CAAE,UAAA,CAAyB,OAAA,CAAQ,CAAC,KAAc,CAAA,KAAc;AAC/D,QAAA,MAAA,CAAO,IAAA,CAAK,GAAG,sBAAA,CAAuB,GAAA,EAAK,GAAG,IAAI,CAAA,YAAA,EAAe,CAAC,CAAA,CAAA,CAAG,CAAC,CAAA;AAAA,MACxE,CAAC,CAAA;AAAA,IACH;AAEA,IAAA,IAAI,CAAA,CAAE,KAAA,IAAS,CAAC,CAAC,KAAA,EAAO,IAAI,CAAA,CAAE,QAAA,CAAS,CAAA,CAAE,KAAK,CAAA,EAAG;AAC/C,MAAA,MAAA,CAAO,IAAA,CAAK,WAAA;AAAA,QACV,GAAG,IAAI,CAAA,MAAA,CAAA;AAAA,QACP,6BAAA;AAAA,QACA;AAAA,OACD,CAAA;AAAA,IACH;AAAA,EACF;AAEA,EAAA,OAAO,MAAA;AACT;AAKA,SAAS,mBAAA,CACP,KAAA,EACA,IAAA,EACA,OAAA,EACmB;AACnB,EAAA,MAAM,SAA4B,EAAC;AACnC,EAAA,MAAM,UAAA,GAAa,QAAQ,eAAA,IAAmB,mBAAA;AAE9C,EAAA,IAAI,CAAC,QAAA,CAAS,KAAK,CAAA,EAAG;AACpB,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA,CAAY,IAAA,EAAM,uCAAuC,CAAC,CAAA;AACtE,IAAA,OAAO,MAAA;AAAA,EACT;AAEA,EAAA,MAAM,CAAA,GAAI,KAAA;AAGV,EAAA,IAAI,CAAC,gBAAA,CAAiB,CAAA,CAAE,IAAI,CAAA,EAAG;AAC7B,IAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,KAAA,CAAA,EAAS,iDAAiD,CAAC,CAAA;AAAA,EAC5F;AAEA,EAAA,IAAI,CAAC,gBAAA,CAAiB,CAAA,CAAE,IAAI,CAAA,EAAG;AAC7B,IAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,KAAA,CAAA,EAAS,kBAAkB,CAAC,CAAA;AAAA,EAC7D,CAAA,MAAA,IAAW,CAAC,UAAA,CAAW,QAAA,CAAS,EAAE,IAAI,CAAA,IAAK,CAAA,CAAE,IAAA,KAAS,SAAA,EAAW;AAC/D,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA;AAAA,MACV,GAAG,IAAI,CAAA,KAAA,CAAA;AAAA,MACP,CAAA,oBAAA,EAAuB,EAAE,IAAI,CAAA,CAAA;AAAA,MAC7B,SAAA;AAAA,MACA,CAAA,aAAA,EAAgB,UAAA,CAAW,IAAA,CAAK,IAAI,CAAC,CAAA,iCAAA;AAAA,KACtC,CAAA;AAAA,EACH;AAGA,EAAA,IAAI,CAAC,EAAE,KAAA,EAAO;AACZ,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA;AAAA,MACV,GAAG,IAAI,CAAA,MAAA,CAAA;AAAA,MACP,wCAAA;AAAA,MACA;AAAA,KACD,CAAA;AAAA,EACH;AAGA,EAAA,IAAI,CAAC,UAAU,aAAA,EAAe,OAAO,EAAE,QAAA,CAAS,CAAA,CAAE,IAAI,CAAA,EAAG;AACvD,IAAA,IAAI,CAAC,CAAA,CAAE,OAAA,IAAW,CAAC,EAAE,UAAA,EAAY;AAC/B,MAAA,MAAA,CAAO,IAAA,CAAK,WAAA;AAAA,QACV,GAAG,IAAI,CAAA,QAAA,CAAA;AAAA,QACP,CAAA,EAAG,EAAE,IAAI,CAAA,qCAAA,CAAA;AAAA,QACT;AAAA,OACD,CAAA;AAAA,IACH;AAAA,EACF;AAGA,EAAA,IAAI,EAAE,UAAA,EAAY;AAChB,IAAA,IAAI,YAAA,CAAa,CAAA,CAAE,UAAU,CAAA,EAAG;AAC9B,MAAA,CAAA,CAAE,UAAA,CAAW,OAAA,CAAQ,CAAC,IAAA,EAAM,CAAA,KAAM;AAChC,QAAA,MAAA,CAAO,IAAA,CAAK,GAAG,sBAAA,CAAuB,IAAA,EAAM,GAAG,IAAI,CAAA,YAAA,EAAe,CAAC,CAAA,CAAA,CAAG,CAAC,CAAA;AAAA,MACzE,CAAC,CAAA;AAAA,IACH,CAAA,MAAA,IAAW,QAAA,CAAS,CAAA,CAAE,UAAU,CAAA,EAAG;AACjC,MAAA,MAAA,CAAO,IAAA,CAAK,GAAG,sBAAA,CAAuB,CAAA,CAAE,YAAY,CAAA,EAAG,IAAI,aAAa,CAAC,CAAA;AAAA,IAC3E;AAAA,EACF;AAGA,EAAA,IAAI,EAAE,QAAA,EAAU;AACd,IAAA,MAAA,CAAO,IAAA,CAAK,GAAG,sBAAA,CAAuB,CAAA,CAAE,UAAU,CAAA,EAAG,IAAI,WAAW,CAAC,CAAA;AAAA,EACvE;AAGA,EAAA,IAAI,EAAE,QAAA,EAAU;AACd,IAAA,IAAI,CAAC,QAAA,CAAS,CAAA,CAAE,QAAQ,CAAA,EAAG;AACzB,MAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,SAAA,CAAA,EAAa,4BAA4B,CAAC,CAAA;AAAA,IAC3E,CAAA,MAAO;AACL,MAAA,MAAM,IAAI,CAAA,CAAE,QAAA;AACZ,MAAA,IAAI,CAAC,gBAAA,CAAiB,CAAA,CAAE,OAAO,CAAA,EAAG;AAChC,QAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,iBAAA,CAAA,EAAqB,8BAA8B,CAAC,CAAA;AAAA,MACrF;AACA,MAAA,IAAI,CAAC,YAAA,CAAa,CAAA,CAAE,IAAI,CAAA,EAAG;AACzB,QAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,cAAA,CAAA,EAAkB,+CAA+C,CAAC,CAAA;AAAA,MACnG;AAAA,IACF;AAAA,EACF;AAGA,EAAA,IAAI,EAAE,MAAA,EAAQ;AACZ,IAAA,IAAI,CAAC,QAAA,CAAS,CAAA,CAAE,MAAM,CAAA,EAAG;AACvB,MAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,OAAA,CAAA,EAAW,0BAA0B,CAAC,CAAA;AAAA,IACvE,CAAA,MAAO;AACL,MAAA,MAAM,MAAM,CAAA,CAAE,MAAA;AACd,MAAA,IAAI,GAAA,CAAI,YAAY,MAAA,EAAW;AAC7B,QAAA,IAAI,CAAC,OAAO,SAAA,CAAU,GAAA,CAAI,OAAO,CAAA,IAAM,GAAA,CAAI,UAAqB,CAAA,EAAG;AACjE,UAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,eAAA,CAAA,EAAmB,wCAAwC,CAAC,CAAA;AAAA,QAC7F;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAO,MAAA;AACT;AAKA,SAAS,mBAAA,CACP,OAAA,EACA,IAAA,EACA,OAAA,EACmB;AACnB,EAAA,MAAM,SAA4B,EAAC;AAEnC,EAAA,IAAI,CAAC,QAAA,CAAS,OAAO,CAAA,EAAG;AACtB,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA,CAAY,IAAA,EAAM,2BAA2B,CAAC,CAAA;AAC1D,IAAA,OAAO,MAAA;AAAA,EACT;AAEA,EAAA,MAAM,CAAA,GAAI,OAAA;AAGV,EAAA,IAAI,CAAC,YAAA,CAAa,CAAA,CAAE,MAAM,CAAA,EAAG;AAC3B,IAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,OAAA,CAAA,EAAW,yCAAyC,CAAC,CAAA;AAAA,EACtF,CAAA,MAAA,IAAW,CAAA,CAAE,MAAA,CAAO,MAAA,KAAW,CAAA,EAAG;AAChC,IAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,OAAA,CAAA,EAAW,uBAAA,EAAyB,SAAS,CAAC,CAAA;AAAA,EAC/E,CAAA,MAAO;AACL,IAAA,CAAA,CAAE,MAAA,CAAO,OAAA,CAAQ,CAAC,KAAA,EAAO,CAAA,KAAM;AAC7B,MAAA,MAAA,CAAO,IAAA,CAAK,GAAG,mBAAA,CAAoB,KAAA,EAAO,CAAA,EAAG,IAAI,CAAA,QAAA,EAAW,CAAC,CAAA,CAAA,CAAA,EAAK,OAAO,CAAC,CAAA;AAAA,IAC5E,CAAC,CAAA;AAAA,EACH;AAGA,EAAA,IAAI,EAAE,QAAA,EAAU;AACd,IAAA,MAAA,CAAO,IAAA,CAAK,GAAG,sBAAA,CAAuB,CAAA,CAAE,UAAU,CAAA,EAAG,IAAI,WAAW,CAAC,CAAA;AAAA,EACvE;AAEA,EAAA,OAAO,MAAA;AACT;AAKA,SAAS,oBAAA,CACP,MAAA,EACA,IAAA,EACA,OAAA,EACmB;AACnB,EAAA,MAAM,SAA4B,EAAC;AACnC,EAAA,MAAM,UAAA,GAAa,QAAQ,gBAAA,IAAoB,oBAAA;AAE/C,EAAA,IAAI,CAAC,QAAA,CAAS,MAAM,CAAA,EAAG;AACrB,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA,CAAY,IAAA,EAAM,wCAAwC,CAAC,CAAA;AACvE,IAAA,OAAO,MAAA;AAAA,EACT;AAEA,EAAA,MAAM,CAAA,GAAI,MAAA;AAGV,EAAA,IAAI,CAAC,gBAAA,CAAiB,CAAA,CAAE,GAAG,CAAA,EAAG;AAC5B,IAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,IAAA,CAAA,EAAQ,gDAAgD,CAAC,CAAA;AAAA,EAC1F;AAEA,EAAA,IAAI,CAAC,gBAAA,CAAiB,CAAA,CAAE,MAAM,CAAA,EAAG;AAC/B,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA;AAAA,MACV,GAAG,IAAI,CAAA,OAAA,CAAA;AAAA,MACP,uBAAA;AAAA,MACA,SAAA;AAAA,MACA;AAAA,KACD,CAAA;AAAA,EACH;AAGA,EAAA,IAAI,CAAA,CAAE,IAAA,IAAQ,CAAC,UAAA,CAAW,QAAA,CAAS,EAAE,IAAI,CAAA,IAAK,CAAA,CAAE,IAAA,KAAS,QAAA,EAAU;AACjE,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA;AAAA,MACV,GAAG,IAAI,CAAA,KAAA,CAAA;AAAA,MACP,CAAA,qBAAA,EAAwB,EAAE,IAAI,CAAA,CAAA;AAAA,MAC9B,SAAA;AAAA,MACA,CAAA,aAAA,EAAgB,UAAA,CAAW,IAAA,CAAK,IAAI,CAAC,CAAA;AAAA,KACtC,CAAA;AAAA,EACH;AAGA,EAAA,IAAI,CAAA,CAAE,KAAA,KAAU,MAAA,IAAa,OAAO,CAAA,CAAE,UAAU,QAAA,IAAY,OAAO,CAAA,CAAE,KAAA,KAAU,QAAA,EAAU;AACvF,IAAA,MAAA,CAAO,KAAK,WAAA,CAAY,CAAA,EAAG,IAAI,CAAA,MAAA,CAAA,EAAU,kCAAkC,CAAC,CAAA;AAAA,EAC9E;AAEA,EAAA,OAAO,MAAA;AACT;AASO,SAAS,mBAAA,CACd,MAAA,EACA,OAAA,GAA4B,EAAC,EACX;AAClB,EAAA,MAAM,SAA4B,EAAC;AAEnC,EAAA,IAAI,CAAC,QAAA,CAAS,MAAM,CAAA,EAAG;AACrB,IAAA,OAAO;AAAA,MACL,KAAA,EAAO,KAAA;AAAA,MACP,MAAA,EAAQ,CAAC,WAAA,CAAY,EAAA,EAAI,gCAAgC,CAAC,CAAA;AAAA,MAC1D,UAAU;AAAC,KACb;AAAA,EACF;AAEA,EAAA,MAAM,CAAA,GAAI,MAAA;AAGV,EAAA,IAAI,CAAC,YAAA,CAAa,CAAA,CAAE,OAAO,CAAA,EAAG;AAC5B,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA,CAAY,SAAA,EAAW,0CAA0C,CAAC,CAAA;AAAA,EAChF,CAAA,MAAA,IAAW,CAAA,CAAE,OAAA,CAAQ,MAAA,KAAW,CAAA,EAAG;AACjC,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA,CAAY,SAAA,EAAW,wBAAwB,CAAC,CAAA;AAAA,EAC9D,CAAA,MAAO;AACL,IAAA,CAAA,CAAE,OAAA,CAAQ,OAAA,CAAQ,CAAC,GAAA,EAAK,CAAA,KAAM;AAC5B,MAAA,MAAA,CAAO,IAAA,CAAK,GAAG,oBAAA,CAAqB,GAAA,EAAK,WAAW,CAAC,CAAA,CAAA,CAAA,EAAK,OAAO,CAAC,CAAA;AAAA,IACpE,CAAC,CAAA;AAGD,IAAA,MAAM,OAAO,CAAA,CAAE,OAAA,CAAQ,GAAA,CAAI,CAAA,GAAA,KAAO,IAAI,GAAG,CAAA;AACzC,IAAA,MAAM,UAAA,GAAa,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA,EAAG,MAAM,IAAA,CAAK,OAAA,CAAQ,CAAC,CAAA,KAAM,CAAC,CAAA;AAC9D,IAAA,IAAI,UAAA,CAAW,SAAS,CAAA,EAAG;AACzB,MAAA,MAAA,CAAO,IAAA,CAAK,WAAA;AAAA,QACV,SAAA;AAAA,QACA,CAAA,uBAAA,EAA0B,CAAC,GAAG,IAAI,GAAA,CAAI,UAAU,CAAC,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA,CAAA;AAAA,QAC7D;AAAA,OACD,CAAA;AAAA,IACH;AAAA,EACF;AAGA,EAAA,IAAI,EAAE,UAAA,KAAe,MAAA,IAAa,OAAO,CAAA,CAAE,eAAe,SAAA,EAAW;AACnE,IAAA,IAAI,QAAA,CAAS,CAAA,CAAE,UAAU,CAAA,EAAG;AAC1B,MAAA,MAAM,IAAI,CAAA,CAAE,UAAA;AACZ,MAAA,IAAI,CAAA,CAAE,QAAA,IAAY,OAAO,CAAA,CAAE,aAAa,QAAA,EAAU;AAChD,QAAA,MAAA,CAAO,IAAA,CAAK,WAAA,CAAY,qBAAA,EAAuB,2BAA2B,CAAC,CAAA;AAAA,MAC7E;AAAA,IACF,CAAA,MAAO;AACL,MAAA,MAAA,CAAO,IAAA,CAAK,WAAA,CAAY,YAAA,EAAc,sCAAsC,CAAC,CAAA;AAAA,IAC/E;AAAA,EACF;AAGA,EAAA,IAAI,QAAQ,gBAAA,EAAkB;AAC5B,IAAA,KAAA,MAAW,CAAC,KAAK,SAAS,CAAA,IAAK,OAAO,OAAA,CAAQ,OAAA,CAAQ,gBAAgB,CAAA,EAAG;AACvE,MAAA,MAAM,SAAA,GAAY,CAAA;AAClB,MAAA,IAAI,OAAO,SAAA,EAAW;AACpB,QAAA,MAAA,CAAO,KAAK,GAAG,SAAA,CAAU,UAAU,GAAG,CAAA,EAAG,GAAG,CAAC,CAAA;AAAA,MAC/C;AAAA,IACF;AAAA,EACF;AAGA,EAAA,MAAM,eAAe,MAAA,CAAO,MAAA,CAAO,CAAA,CAAA,KAAK,CAAA,CAAE,aAAa,OAAO,CAAA;AAC9D,EAAA,MAAM,WAAW,MAAA,CAAO,MAAA,CAAO,CAAA,CAAA,KAAK,CAAA,CAAE,aAAa,SAAS,CAAA;AAE5D,EAAA,OAAO;AAAA,IACL,OAAO,OAAA,CAAQ,MAAA,GAAS,OAAO,MAAA,KAAW,CAAA,GAAI,aAAa,MAAA,KAAW,CAAA;AAAA,IACtE,MAAA,EAAQ,YAAA;AAAA,IACR;AAAA,GACF;AACF;AAKO,SAAS,kBAAA,CACd,MAAA,EACA,OAAA,GAA4B,EAAC,EACX;AAClB,EAAA,MAAM,SAA4B,EAAC;AAEnC,EAAA,IAAI,CAAC,QAAA,CAAS,MAAM,CAAA,EAAG;AACrB,IAAA,OAAO;AAAA,MACL,KAAA,EAAO,KAAA;AAAA,MACP,MAAA,EAAQ,CAAC,WAAA,CAAY,EAAA,EAAI,+BAA+B,CAAC,CAAA;AAAA,MACzD,UAAU;AAAC,KACb;AAAA,EACF;AAEA,EAAA,MAAM,CAAA,GAAI,MAAA;AAGV,EAAA,IAAI,CAAC,YAAA,CAAa,CAAA,CAAE,QAAQ,CAAA,EAAG;AAC7B,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA,CAAY,UAAA,EAAY,2CAA2C,CAAC,CAAA;AAAA,EAClF,CAAA,MAAA,IAAW,CAAA,CAAE,QAAA,CAAS,MAAA,KAAW,CAAA,EAAG;AAClC,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA,CAAY,UAAA,EAAY,yBAAyB,CAAC,CAAA;AAAA,EAChE,CAAA,MAAO;AACL,IAAA,CAAA,CAAE,QAAA,CAAS,OAAA,CAAQ,CAAC,OAAA,EAAS,CAAA,KAAM;AACjC,MAAA,MAAA,CAAO,IAAA,CAAK,GAAG,mBAAA,CAAoB,OAAA,EAAS,YAAY,CAAC,CAAA,CAAA,CAAA,EAAK,OAAO,CAAC,CAAA;AAAA,IACxE,CAAC,CAAA;AAAA,EACH;AAGA,EAAA,MAAM,SAAA,GAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,OAAK,CAAA,CAAE,MAAM,KAAK,EAAC;AACzD,EAAA,MAAM,KAAA,GAAQ,SAAA,CAAU,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,IAAI,CAAA;AACvC,EAAA,MAAM,UAAA,GAAa,KAAA,CAAM,MAAA,CAAO,CAAC,CAAA,EAAG,MAAM,KAAA,CAAM,OAAA,CAAQ,CAAC,CAAA,KAAM,CAAC,CAAA;AAChE,EAAA,IAAI,UAAA,CAAW,SAAS,CAAA,EAAG;AACzB,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA;AAAA,MACV,UAAA;AAAA,MACA,CAAA,uBAAA,EAA0B,CAAC,GAAG,IAAI,GAAA,CAAI,UAAU,CAAC,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA,CAAA;AAAA,MAC7D;AAAA,KACD,CAAA;AAAA,EACH;AAGA,EAAA,IAAI,CAAC,gBAAA,CAAiB,CAAA,CAAE,EAAE,CAAA,EAAG;AAC3B,IAAA,MAAA,CAAO,IAAA,CAAK,WAAA,CAAY,IAAA,EAAM,mBAAA,EAAqB,SAAS,CAAC,CAAA;AAAA,EAC/D;AAGA,EAAA,IAAI,QAAQ,gBAAA,EAAkB;AAC5B,IAAA,KAAA,MAAW,CAAC,KAAK,SAAS,CAAA,IAAK,OAAO,OAAA,CAAQ,OAAA,CAAQ,gBAAgB,CAAA,EAAG;AACvE,MAAA,MAAM,SAAA,GAAY,CAAA;AAClB,MAAA,IAAI,OAAO,SAAA,EAAW;AACpB,QAAA,MAAA,CAAO,KAAK,GAAG,SAAA,CAAU,UAAU,GAAG,CAAA,EAAG,GAAG,CAAC,CAAA;AAAA,MAC/C;AAAA,IACF;AAAA,EACF;AAGA,EAAA,MAAM,eAAe,MAAA,CAAO,MAAA,CAAO,CAAA,CAAA,KAAK,CAAA,CAAE,aAAa,OAAO,CAAA;AAC9D,EAAA,MAAM,WAAW,MAAA,CAAO,MAAA,CAAO,CAAA,CAAA,KAAK,CAAA,CAAE,aAAa,SAAS,CAAA;AAE5D,EAAA,OAAO;AAAA,IACL,OAAO,OAAA,CAAQ,MAAA,GAAS,OAAO,MAAA,KAAW,CAAA,GAAI,aAAa,MAAA,KAAW,CAAA;AAAA,IACtE,MAAA,EAAQ,YAAA;AAAA,IACR;AAAA,GACF;AACF;AAKO,SAAS,cAAA,CACd,MAAA,EACA,OAAA,GAA4B,EAAC,EACX;AAClB,EAAA,IAAI,CAAC,QAAA,CAAS,MAAM,CAAA,EAAG;AACrB,IAAA,OAAO;AAAA,MACL,KAAA,EAAO,KAAA;AAAA,MACP,MAAA,EAAQ,CAAC,WAAA,CAAY,EAAA,EAAI,0BAA0B,CAAC,CAAA;AAAA,MACpD,UAAU;AAAC,KACb;AAAA,EACF;AAEA,EAAA,MAAM,CAAA,GAAI,MAAA;AAGV,EAAA,IAAI,aAAa,CAAA,EAAG;AAClB,IAAA,OAAO,mBAAA,CAAoB,QAAQ,OAAO,CAAA;AAAA,EAC5C;AAEA,EAAA,IAAI,cAAc,CAAA,EAAG;AACnB,IAAA,OAAO,kBAAA,CAAmB,QAAQ,OAAO,CAAA;AAAA,EAC3C;AAEA,EAAA,OAAO;AAAA,IACL,KAAA,EAAO,KAAA;AAAA,IACP,MAAA,EAAQ,CAAC,WAAA,CAAY,EAAA,EAAI,uEAAuE,CAAC,CAAA;AAAA,IACjG,UAAU;AAAC,GACb;AACF;AASO,SAAS,uBAAuB,MAAA,EAAkC;AACvE,EAAA,MAAM,QAAkB,EAAC;AAEzB,EAAA,IAAI,MAAA,CAAO,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG;AAC5B,IAAA,KAAA,CAAM,KAAK,SAAS,CAAA;AACpB,IAAA,MAAA,CAAO,MAAA,CAAO,QAAQ,CAAA,CAAA,KAAK;AACzB,MAAA,KAAA,CAAM,IAAA,CAAK,YAAO,CAAA,CAAE,IAAA,IAAQ,MAAM,CAAA,EAAA,EAAK,CAAA,CAAE,OAAO,CAAA,CAAE,CAAA;AAClD,MAAA,IAAI,EAAE,UAAA,EAAY;AAChB,QAAA,KAAA,CAAM,IAAA,CAAK,CAAA,WAAA,EAAS,CAAA,CAAE,UAAU,CAAA,CAAE,CAAA;AAAA,MACpC;AAAA,IACF,CAAC,CAAA;AAAA,EACH;AAEA,EAAA,IAAI,MAAA,CAAO,QAAA,CAAS,MAAA,GAAS,CAAA,EAAG;AAC9B,IAAA,KAAA,CAAM,KAAK,WAAW,CAAA;AACtB,IAAA,MAAA,CAAO,QAAA,CAAS,QAAQ,CAAA,CAAA,KAAK;AAC3B,MAAA,KAAA,CAAM,IAAA,CAAK,YAAO,CAAA,CAAE,IAAA,IAAQ,MAAM,CAAA,EAAA,EAAK,CAAA,CAAE,OAAO,CAAA,CAAE,CAAA;AAClD,MAAA,IAAI,EAAE,UAAA,EAAY;AAChB,QAAA,KAAA,CAAM,IAAA,CAAK,CAAA,WAAA,EAAS,CAAA,CAAE,UAAU,CAAA,CAAE,CAAA;AAAA,MACpC;AAAA,IACF,CAAC,CAAA;AAAA,EACH;AAEA,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;AAKO,SAAS,iBAAA,CACd,MAAA,EACA,OAAA,GAA4B,EAAC,EACvB;AACN,EAAA,MAAM,MAAA,GAAS,cAAA,CAAe,MAAA,EAAQ,OAAO,CAAA;AAE7C,EAAA,IAAI,CAAC,OAAO,KAAA,EAAO;AACjB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA;AAAA,EAA2B,sBAAA,CAAuB,MAAM,CAAC,CAAA,CAAE,CAAA;AAAA,EAC7E;AACF;;;ACviBA,SAAS,YAAY,GAAA,EAAqB;AACxC,EAAA,OAAO,GAAA,CACJ,OAAA,CAAQ,UAAA,EAAY,KAAK,CAAA,CACzB,OAAA,CAAQ,OAAA,EAAS,GAAG,CAAA,CACpB,OAAA,CAAQ,MAAA,EAAQ,GAAG,CAAA,CACnB,IAAA,EAAK,CACL,OAAA,CAAQ,KAAA,EAAO,CAAA,CAAA,KAAK,CAAA,CAAE,WAAA,EAAa,CAAA,CACnC,OAAA,CAAQ,OAAA,EAAS,CAAA,CAAA,KAAK,CAAA,CAAE,WAAA,EAAa,CAAA;AAC1C;AAKA,SAAS,UAAa,GAAA,EAAW;AAC/B,EAAA,IAAI,GAAA,KAAQ,IAAA,IAAQ,OAAO,GAAA,KAAQ,UAAU,OAAO,GAAA;AACpD,EAAA,IAAI,MAAM,OAAA,CAAQ,GAAG,GAAG,OAAO,GAAA,CAAI,IAAI,SAAS,CAAA;AAEhD,EAAA,MAAM,SAAkC,EAAC;AACzC,EAAA,KAAA,MAAW,OAAO,GAAA,EAAK;AACrB,IAAA,IAAI,OAAO,SAAA,CAAU,cAAA,CAAe,IAAA,CAAK,GAAA,EAAK,GAAG,CAAA,EAAG;AAClD,MAAA,MAAA,CAAO,GAAG,CAAA,GAAI,SAAA,CAAW,GAAA,CAAgC,GAAG,CAAC,CAAA;AAAA,IAC/D;AAAA,EACF;AACA,EAAA,OAAO,MAAA;AACT;AA2BA,SAAS,wBAAwB,IAAA,EAAsC;AACrE,EAAA,IAAI,CAAC,IAAA,IAAQ,OAAO,IAAA,KAAS,UAAU,OAAO,IAAA;AAE9C,EAAA,MAAM,CAAA,GAAI,IAAA;AAGV,EAAA,IAAI,MAAA,IAAU,CAAA,IAAK,OAAO,CAAA,CAAE,SAAS,QAAA,EAAU;AAC7C,IAAA,OAAO;AAAA,MACL,MAAM,CAAA,CAAE,IAAA;AAAA,MACR,OAAO,CAAA,CAAE,KAAA;AAAA,MACT,SAAS,OAAO,CAAA,CAAE,OAAA,KAAY,QAAA,GAAW,EAAE,OAAA,GAAU;AAAA,KACvD;AAAA,EACF;AAGA,EAAA,MAAM,QAA0B,EAAC;AAEjC,EAAA,IAAI,UAAA,IAAc,CAAA,IAAK,CAAA,CAAE,QAAA,EAAU;AACjC,IAAA,KAAA,CAAM,IAAA,CAAK,EAAE,IAAA,EAAM,UAAA,EAAY,OAAA,EAAS,OAAO,CAAA,CAAE,OAAA,KAAY,QAAA,GAAW,CAAA,CAAE,OAAA,GAAU,MAAA,EAAW,CAAA;AAAA,EACjG;AACA,EAAA,IAAI,KAAA,IAAS,CAAA,IAAK,OAAO,CAAA,CAAE,QAAQ,QAAA,EAAU;AAC3C,IAAA,KAAA,CAAM,KAAK,EAAE,IAAA,EAAM,OAAO,KAAA,EAAO,CAAA,CAAE,KAAK,CAAA;AAAA,EAC1C;AACA,EAAA,IAAI,KAAA,IAAS,CAAA,IAAK,OAAO,CAAA,CAAE,QAAQ,QAAA,EAAU;AAC3C,IAAA,KAAA,CAAM,KAAK,EAAE,IAAA,EAAM,OAAO,KAAA,EAAO,CAAA,CAAE,KAAK,CAAA;AAAA,EAC1C;AACA,EAAA,IAAI,WAAA,IAAe,CAAA,IAAK,OAAO,CAAA,CAAE,cAAc,QAAA,EAAU;AACvD,IAAA,KAAA,CAAM,KAAK,EAAE,IAAA,EAAM,aAAa,KAAA,EAAO,CAAA,CAAE,WAAW,CAAA;AAAA,EACtD;AACA,EAAA,IAAI,WAAA,IAAe,CAAA,IAAK,OAAO,CAAA,CAAE,cAAc,QAAA,EAAU;AACvD,IAAA,KAAA,CAAM,KAAK,EAAE,IAAA,EAAM,aAAa,KAAA,EAAO,CAAA,CAAE,WAAW,CAAA;AAAA,EACtD;AACA,EAAA,IAAI,SAAA,IAAa,CAAA,IAAK,OAAO,CAAA,CAAE,YAAY,QAAA,EAAU;AACnD,IAAA,KAAA,CAAM,KAAK,EAAE,IAAA,EAAM,WAAW,KAAA,EAAO,CAAA,CAAE,SAAS,CAAA;AAAA,EAClD;AACA,EAAA,IAAI,OAAA,IAAW,CAAA,IAAK,CAAA,CAAE,KAAA,EAAO;AAC3B,IAAA,KAAA,CAAM,IAAA,CAAK,EAAE,IAAA,EAAM,OAAA,EAAS,CAAA;AAAA,EAC9B;AACA,EAAA,IAAI,KAAA,IAAS,CAAA,IAAK,CAAA,CAAE,GAAA,EAAK;AACvB,IAAA,KAAA,CAAM,IAAA,CAAK,EAAE,IAAA,EAAM,KAAA,EAAO,CAAA;AAAA,EAC5B;AAEA,EAAA,OAAO,KAAA,CAAM,MAAA,GAAS,CAAA,GAAI,KAAA,CAAM,CAAC,CAAA,GAAI,IAAA;AACvC;AAgBA,SAAS,wBAAwB,SAAA,EAAkD;AACjF,EAAA,IAAI,CAAC,SAAA,IAAa,OAAO,SAAA,KAAc,UAAU,OAAO,MAAA;AAExD,EAAA,MAAM,CAAA,GAAI,SAAA;AAGV,EAAA,IAAI,CAAA,CAAE,KAAA,IAAS,OAAO,CAAA,CAAE,UAAU,QAAA,EAAU;AAC1C,IAAA,OAAO;AAAA,MACL,OAAO,CAAA,CAAE,KAAA;AAAA,MACT,UAAU,OAAO,CAAA,CAAE,QAAA,KAAa,QAAA,GAAW,EAAE,QAAA,GAAW,QAAA;AAAA,MACxD,OAAO,CAAA,CAAE;AAAA,KACX;AAAA,EACF;AAGA,EAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,CAAA,CAAE,UAAU,CAAA,EAAG;AAC/B,IAAA,OAAO;AAAA,MACL,KAAA,EAAQ,EAAE,KAAA,IAA0B,KAAA;AAAA,MACpC,UAAA,EAAY,CAAA,CAAE,UAAA,CACX,GAAA,CAAI,uBAAuB,EAC3B,MAAA,CAAO,CAAC,IAAA,KAAmC,IAAA,KAAS,MAAS;AAAA,KAClE;AAAA,EACF;AAEA,EAAA,OAAO,MAAA;AACT;AAKA,SAAS,cAAA,CACP,KACA,OAAA,EACa;AACb,EAAA,MAAM;AAAA,IACJ,eAAA,GAAkB,KAAA;AAAA,IAClB,kBAAA;AAAA,IACA,cAAA,GAAiB,IAAA;AAAA,IACjB,mBAAmB;AAAC,GACtB,GAAI,OAAA;AAGJ,EAAA,MAAM,OAAO,kBAAA,GAAqB,kBAAA,CAAmB,GAAA,CAAI,IAAI,IAAI,GAAA,CAAI,IAAA;AAErE,EAAA,MAAM,UAAA,GAA0B;AAAA,IAC9B,IAAA;AAAA,IACA,IAAA,EAAO,IAAI,IAAA,IAAQ,MAAA;AAAA,IACnB,OAAQ,GAAA,CAAI,KAAA,KAAU,cAAA,GAAiB,WAAA,CAAY,IAAI,CAAA,GAAI,IAAA,CAAA;AAAA,IAC3D,QAAA,EAAW,IAAI,QAAA,IAAoC,eAAA;AAAA,IACnD,QAAA,EAAW,IAAI,QAAA,IAAoC,KAAA;AAAA,IACnD,QAAA,EAAW,IAAI,QAAA,IAAoC,KAAA;AAAA,IACnD,aAAa,GAAA,CAAI,WAAA;AAAA,IACjB,UAAU,GAAA,CAAI,QAAA;AAAA,IACd,cAAc,GAAA,CAAI;AAAA,GACpB;AAGA,EAAA,IAAI,IAAI,OAAA,EAAS;AACf,IAAA,UAAA,CAAW,OAAA,GAAU,SAAA,CAAU,GAAA,CAAI,OAAO,CAAA;AAAA,EAC5C;AAEA,EAAA,IAAI,IAAI,UAAA,EAAY;AAClB,IAAA,UAAA,CAAW,aAAa,GAAA,CAAI,UAAA;AAAA,EAC9B;AAEA,EAAA,IAAI,GAAA,CAAI,GAAA,KAAQ,MAAA,EAAW,UAAA,CAAW,MAAM,GAAA,CAAI,GAAA;AAChD,EAAA,IAAI,GAAA,CAAI,GAAA,KAAQ,MAAA,EAAW,UAAA,CAAW,MAAM,GAAA,CAAI,GAAA;AAChD,EAAA,IAAI,GAAA,CAAI,SAAA,KAAc,MAAA,EAAW,UAAA,CAAW,YAAY,GAAA,CAAI,SAAA;AAC5D,EAAA,IAAI,GAAA,CAAI,SAAA,KAAc,MAAA,EAAW,UAAA,CAAW,YAAY,GAAA,CAAI,SAAA;AAG5D,EAAA,IAAI,IAAI,UAAA,EAAY;AAClB,IAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,GAAA,CAAI,UAAU,CAAA,EAAG;AACjC,MAAA,UAAA,CAAW,UAAA,GAAa,GAAA,CAAI,UAAA,CACzB,GAAA,CAAI,uBAAuB,EAC3B,MAAA,CAAO,CAAC,CAAA,KAA2B,CAAA,KAAM,IAAI,CAAA;AAAA,IAClD,CAAA,MAAO;AACL,MAAA,MAAM,IAAA,GAAO,uBAAA,CAAwB,GAAA,CAAI,UAAU,CAAA;AACnD,MAAA,IAAI,IAAA,EAAM,UAAA,CAAW,UAAA,GAAa,CAAC,IAAI,CAAA;AAAA,IACzC;AAAA,EACF;AAGA,EAAA,IAAI,IAAI,QAAA,EAAU;AAChB,IAAA,UAAA,CAAW,QAAA,GAAW,uBAAA,CAAwB,GAAA,CAAI,QAAQ,CAAA;AAAA,EAC5D;AAGA,EAAA,IAAI,GAAA,CAAI,QAAA,IAAY,OAAO,GAAA,CAAI,aAAa,QAAA,EAAU;AACpD,IAAA,MAAM,IAAI,GAAA,CAAI,QAAA;AACd,IAAA,IAAI,OAAO,EAAE,OAAA,KAAY,QAAA,IAAY,MAAM,OAAA,CAAQ,CAAA,CAAE,IAAI,CAAA,EAAG;AAC1D,MAAA,UAAA,CAAW,QAAA,GAAW;AAAA,QACpB,SAAS,CAAA,CAAE,OAAA;AAAA,QACX,IAAA,EAAM,EAAE,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA,KAAmB,OAAO,MAAM,QAAQ;AAAA,OAC/D;AAAA,IACF;AAAA,EACF;AAGA,EAAA,IAAI,gBAAA,CAAiB,GAAA,CAAI,IAAI,CAAA,EAAG;AAC9B,IAAA,MAAA,CAAO,OAAO,UAAA,EAAY,gBAAA,CAAiB,IAAI,IAAI,CAAA,CAAE,GAAG,CAAC,CAAA;AAAA,EAC3D;AAGA,EAAA,MAAM,SAAA,uBAAgB,GAAA,CAAI;AAAA,IACxB,MAAA;AAAA,IAAQ,MAAA;AAAA,IAAQ,OAAA;AAAA,IAAS,UAAA;AAAA,IAAY,UAAA;AAAA,IAAY,UAAA;AAAA,IACjD,aAAA;AAAA,IAAe,YAAA;AAAA,IAAc,cAAA;AAAA,IAAgB,SAAA;AAAA,IAAW,YAAA;AAAA,IACxD,KAAA;AAAA,IAAO,KAAA;AAAA,IAAO,WAAA;AAAA,IAAa,WAAA;AAAA,IAAa,YAAA;AAAA,IAAc,UAAA;AAAA,IAAY;AAAA,GACnE,CAAA;AAED,EAAA,KAAA,MAAW,OAAO,GAAA,EAAK;AACrB,IAAA,IAAI,CAAC,UAAU,GAAA,CAAI,GAAG,KAAK,GAAA,CAAI,GAAG,MAAM,MAAA,EAAW;AACjD,MAAC,WAAkD,GAAG,CAAA,GAAI,SAAA,CAAU,GAAA,CAAI,GAAG,CAAC,CAAA;AAAA,IAC9E;AAAA,EACF;AAEA,EAAA,OAAO,UAAA;AACT;AAKA,SAAS,gBAAA,CACP,KACA,OAAA,EACa;AACb,EAAA,MAAM,UAAA,GAA0B;AAAA,IAC9B,EAAA,EAAI,GAAA,CAAI,EAAA,KAAO,GAAA,CAAI,KAAA,EAAO,aAAY,CAAE,OAAA,CAAQ,MAAA,EAAQ,GAAG,CAAA,IAAK,SAAA,CAAA;AAAA,IAChE,KAAA,EAAO,IAAI,KAAA,IAAS,SAAA;AAAA,IACpB,aAAa,GAAA,CAAI,WAAA;AAAA,IACjB,WAAA,EAAc,IAAI,WAAA,IAAuC,KAAA;AAAA,IACzD,gBAAA,EAAmB,IAAI,SAAA,IAAqC,KAAA;AAAA,IAC5D,MAAA,EAAQ,IAAI,MAAA,CAAO,GAAA,CAAI,OAAK,cAAA,CAAe,CAAA,EAAG,OAAO,CAAC;AAAA,GACxD;AAEA,EAAA,IAAI,IAAI,QAAA,EAAU;AAChB,IAAA,UAAA,CAAW,QAAA,GAAW,uBAAA,CAAwB,GAAA,CAAI,QAAQ,CAAA;AAAA,EAC5D;AAGA,EAAA,IAAI,IAAI,OAAA,EAAS;AACf,IAAA,UAAA,CAAW,UAAU,GAAA,CAAI,OAAA;AAAA,EAC3B;AAEA,EAAA,OAAO,UAAA;AACT;AAKA,SAAS,eAAA,CACP,KACA,OAAA,EACc;AACd,EAAA,MAAM;AAAA,IACJ,kBAAA;AAAA,IACA,eAAA,GAAkB,IAAA;AAAA,IAClB,kBAAA;AAAA,IACA,cAAA,GAAiB,IAAA;AAAA,IACjB,oBAAoB;AAAC,GACvB,GAAI,OAAA;AAEJ,EAAA,MAAM,MAAM,kBAAA,GAAqB,kBAAA,CAAmB,GAAA,CAAI,GAAG,IAAI,GAAA,CAAI,GAAA;AAEnE,EAAA,MAAM,UAAA,GAA2B;AAAA,IAC/B,GAAA;AAAA,IACA,QAAA,EAAU,IAAI,QAAA,IAAY,GAAA;AAAA,IAC1B,QAAQ,GAAA,CAAI,MAAA,KAAW,cAAA,GAAiB,WAAA,CAAY,GAAG,CAAA,GAAI,GAAA,CAAA;AAAA,IAC3D,IAAA,EAAO,IAAI,IAAA,IAAQ,MAAA;AAAA,IACnB,KAAA,EAAQ,OAAO,GAAA,CAAI,KAAA,KAAU,QAAA,IAAY,OAAO,GAAA,CAAI,KAAA,KAAU,QAAA,GAAY,GAAA,CAAI,KAAA,GAAQ,kBAAA;AAAA,IACtF,UAAU,GAAA,CAAI,QAAA;AAAA,IACd,UAAU,GAAA,CAAI,QAAA;AAAA,IACd,QAAA,EAAW,IAAI,QAAA,IAAoC,eAAA;AAAA,IACnD,UAAA,EAAa,IAAI,UAAA,IAAsC,KAAA;AAAA,IACvD,OAAA,EAAS,GAAA,CAAI,MAAA,GAAS,KAAA,GAAS,IAAI,OAAA,IAAmC,IAAA;AAAA,IACtE,KAAA,EAAQ,IAAI,KAAA,IAAmC;AAAA,GACjD;AAGA,EAAA,IAAI,GAAA,CAAI,MAAA,EAAQ,UAAA,CAAW,MAAA,GAAS,GAAA,CAAI,MAAA;AACxC,EAAA,IAAI,GAAA,CAAI,MAAA,EAAQ,UAAA,CAAW,MAAA,GAAS,GAAA,CAAI,MAAA;AAGxC,EAAA,MAAM,IAAA,GAAQ,GAAA,CAAI,IAAA,IAAS,GAAA,CAAY,QAAA,IAAY,MAAA;AACnD,EAAA,IAAI,iBAAA,CAAkB,IAAI,CAAA,EAAG;AAC3B,IAAA,MAAA,CAAO,OAAO,UAAA,EAAY,iBAAA,CAAkB,IAAI,CAAA,CAAE,GAAG,CAAC,CAAA;AAAA,EACxD;AAEA,EAAA,UAAA,CAAW,IAAA,GAAO,IAAA;AAGlB,EAAA,MAAM,SAAA,uBAAgB,GAAA,CAAI;AAAA,IACxB,KAAA;AAAA,IAAO,QAAA;AAAA,IAAU,MAAA;AAAA,IAAQ,OAAA;AAAA,IAAS,UAAA;AAAA,IAAY,UAAA;AAAA,IAC9C,UAAA;AAAA,IAAY,YAAA;AAAA,IAAc,QAAA;AAAA,IAAU,OAAA;AAAA,IAAS,QAAA;AAAA,IAC7C,QAAA;AAAA,IAAU,UAAA;AAAA,IAAY,cAAA;AAAA,IAAgB;AAAA,GACvC,CAAA;AAED,EAAA,KAAA,MAAW,KAAK,GAAA,EAAK;AACnB,IAAA,IAAI,CAAC,UAAU,GAAA,CAAI,CAAC,KAAK,GAAA,CAAI,CAAC,MAAM,MAAA,EAAW;AAC7C,MAAC,WAAkD,CAAC,CAAA,GAAI,SAAA,CAAU,GAAA,CAAI,CAAC,CAAC,CAAA;AAAA,IAC1E;AAAA,EACF;AAEA,EAAA,OAAO,UAAA;AACT;AASO,SAAS,gBAAA,CACd,GAAA,EACA,OAAA,GAAyB,EAAC,EACb;AACb,EAAA,MAAM,OAAA,GAAU,IAAI,OAAA,CAAQ,GAAA,CAAI,OAAK,eAAA,CAAgB,CAAA,EAAG,OAAO,CAAC,CAAA;AAEhE,EAAA,MAAM,MAAA,GAAsB;AAAA,IAC1B,OAAA;AAAA,IACA,YAAY,GAAA,CAAI,UAAA;AAAA,IAChB,WAAW,GAAA,CAAI,SAAA;AAAA,IACf,SAAS,GAAA,CAAI,OAAA;AAAA,IACb,SAAU,GAAA,CAAI,OAAA;AAAA,IACd,UAAW,GAAA,CAAI,QAAA;AAAA,IACf,SAAU,GAAA,CAAI,OAAA;AAAA,IACd,WAAY,GAAA,CAAI,SAAA;AAAA,IAChB,cAAc,GAAA,CAAI,YAAA;AAAA,IAClB,gBAAgB,GAAA,CAAI,cAAA;AAAA,IACpB,QAAQ,GAAA,CAAI,MAAA;AAAA,IACZ,mBAAmB,GAAA,CAAI,iBAAA;AAAA,IACvB,sBAAsB,GAAA,CAAI;AAAA,GAC5B;AAGA,EAAA,MAAM,SAAA,uBAAgB,GAAA,CAAI;AAAA,IACxB,SAAA;AAAA,IAAW,YAAA;AAAA,IAAc,WAAA;AAAA,IAAa,SAAA;AAAA,IACtC,SAAA;AAAA,IAAW,UAAA;AAAA,IAAY,SAAA;AAAA,IAAW,WAAA;AAAA,IAClC,cAAA;AAAA,IAAgB,gBAAA;AAAA,IAAkB,QAAA;AAAA,IAClC,mBAAA;AAAA,IAAqB;AAAA,GACtB,CAAA;AAED,EAAA,KAAA,MAAW,OAAO,GAAA,EAAK;AACrB,IAAA,IAAI,CAAC,UAAU,GAAA,CAAI,GAAG,KAAK,GAAA,CAAI,GAAG,MAAM,MAAA,EAAW;AACjD,MAAC,OAA8C,GAAG,CAAA,GAAI,SAAA,CAAU,GAAA,CAAI,GAAG,CAAC,CAAA;AAAA,IAC1E;AAAA,EACF;AAEA,EAAA,OAAO,MAAA;AACT;AAKO,SAAS,eAAA,CACd,GAAA,EACA,OAAA,GAAyB,EAAC,EACd;AACZ,EAAA,MAAM,QAAA,GAAW,IAAI,QAAA,CAAS,GAAA,CAAI,OAAK,gBAAA,CAAiB,CAAA,EAAG,OAAO,CAAC,CAAA;AAEnE,EAAA,MAAM,MAAA,GAAqB;AAAA,IACzB,EAAA,EAAI,IAAI,EAAA,IAAM,MAAA;AAAA,IACd,KAAA,EAAO,IAAI,KAAA,IAAS,MAAA;AAAA,IACpB,QAAA;AAAA,IACA,aAAa,GAAA,CAAI,WAAA;AAAA,IACjB,aAAa,GAAA,CAAI,WAAA;AAAA,IACjB,YAAa,GAAA,CAAI,UAAA;AAAA,IACjB,MAAO,GAAA,CAAI,IAAA;AAAA,IACX,gBAAiB,GAAA,CAAI;AAAA,GACvB;AAGA,EAAA,MAAM,SAAA,uBAAgB,GAAA,CAAI;AAAA,IACxB,IAAA;AAAA,IAAM,OAAA;AAAA,IAAS,UAAA;AAAA,IAAY,QAAA;AAAA,IAAU,aAAA;AAAA,IAAe,aAAA;AAAA,IACpD,YAAA;AAAA,IAAc,MAAA;AAAA,IAAQ;AAAA,GACvB,CAAA;AAED,EAAA,KAAA,MAAW,OAAO,GAAA,EAAK;AACrB,IAAA,IAAI,CAAC,UAAU,GAAA,CAAI,GAAG,KAAK,GAAA,CAAI,GAAG,MAAM,MAAA,EAAW;AACjD,MAAC,OAA8C,GAAG,CAAA,GAAI,SAAA,CAAU,GAAA,CAAI,GAAG,CAAC,CAAA;AAAA,IAC1E;AAAA,EACF;AAEA,EAAA,OAAO,MAAA;AACT;AAKO,SAAS,WAAA,CACd,GAAA,EACA,OAAA,GAAyB,EAAC,EACvB;AACH,EAAA,IAAI,aAAa,GAAA,EAAK;AACpB,IAAA,OAAO,gBAAA,CAAiB,KAAuB,OAAO,CAAA;AAAA,EACxD;AAEA,EAAA,IAAI,cAAc,GAAA,EAAK;AACrB,IAAA,OAAO,eAAA,CAAgB,KAAsB,OAAO,CAAA;AAAA,EACtD;AAEA,EAAA,MAAM,IAAI,MAAM,uEAAuE,CAAA;AACzF;AAqBO,IAAM,eAAN,MAAmB;AAAA,EAIxB,WAAA,CAAY,OAAA,GAA+B,EAAC,EAAG;AAH/C,IAAA,IAAA,CAAQ,KAAA,uBAAmD,GAAA,EAAI;AAI7D,IAAA,IAAA,CAAK,OAAA,GAAU;AAAA,MACb,QAAA,EAAU,UAAA;AAAA,MACV,KAAA,EAAO,IAAA;AAAA,MACP,QAAA,EAAU,IAAA;AAAA,MACV,GAAG;AAAA,KACL;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KAAyC,IAAA,EAA0B;AAEvE,IAAA,IAAI,KAAK,OAAA,CAAQ,KAAA,IAAS,KAAK,KAAA,CAAM,GAAA,CAAI,IAAI,CAAA,EAAG;AAC9C,MAAA,OAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,IAAI,CAAA;AAAA,IAC5B;AAGA,IAAA,MAAM,GAAA,GAAM,IAAA,CAAK,UAAA,CAAW,MAAM,CAAA,GAC9B,IAAA,GACA,CAAA,EAAG,IAAA,CAAK,OAAA,CAAQ,QAAQ,CAAA,CAAA,EAAI,IAAI,CAAA,CAAA;AAEpC,IAAA,IAAI;AACF,MAAA,MAAM,QAAA,GAAW,MAAM,KAAA,CAAM,GAAG,CAAA;AAEhC,MAAA,IAAI,CAAC,SAAS,EAAA,EAAI;AAChB,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,uBAAA,EAA0B,QAAA,CAAS,UAAU,CAAA,CAAE,CAAA;AAAA,MACjE;AAEA,MAAA,MAAM,GAAA,GAAM,MAAM,QAAA,CAAS,IAAA,EAAK;AAChC,MAAA,MAAM,MAAA,GAAS,WAAA,CAAe,GAAA,EAAK,IAAA,CAAK,OAAO,CAAA;AAG/C,MAAA,IAAI,IAAA,CAAK,QAAQ,KAAA,EAAO;AACtB,QAAA,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,IAAA,EAAM,MAAM,CAAA;AAAA,MAC7B;AAEA,MAAA,OAAO,MAAA;AAAA,IACT,SAAS,KAAA,EAAO;AACd,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,2BAAA,EAA8B,IAAI,CAAA,EAAA,EAAK,KAAK,CAAA,CAAE,CAAA;AAAA,IAChE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAA6C,KAAA,EAA+B;AAChF,IAAA,OAAO,OAAA,CAAQ,IAAI,KAAA,CAAM,GAAA,CAAI,UAAQ,IAAA,CAAK,IAAA,CAAQ,IAAI,CAAC,CAAC,CAAA;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA,EAKA,UAAA,GAAmB;AACjB,IAAA,IAAA,CAAK,MAAM,KAAA,EAAM;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW,IAAA,EAAoB;AAC7B,IAAA,IAAA,CAAK,KAAA,CAAM,OAAO,IAAI,CAAA;AAAA,EACxB;AACF;AAKO,SAAS,mBAAmB,OAAA,EAA6C;AAC9E,EAAA,OAAO,IAAI,aAAa,OAAO,CAAA;AACjC","file":"chunk-G2IQSWID.js","sourcesContent":["/**\n * @fileoverview Config Validator - Validates JSON configuration schemas\n * \n * Provides comprehensive validation for table and form configurations,\n * with helpful error messages for debugging.\n * \n * @module config-system/ConfigValidator\n */\n\nimport type {\n  TableConfig,\n  FormConfig,\n  ColumnConfig,\n  FieldConfig,\n  FormSection,\n  ValidationRule,\n  FieldCondition,\n  DataRecord,\n} from '../core/types';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Validation error details\n */\nexport interface ValidationError {\n  /** Path to the invalid property */\n  path: string;\n  /** Error message */\n  message: string;\n  /** Suggested fix */\n  suggestion?: string;\n  /** Severity level */\n  severity: 'error' | 'warning';\n}\n\n/**\n * Validation result\n */\nexport interface ValidationResult {\n  /** Whether validation passed (no errors) */\n  valid: boolean;\n  /** List of validation errors */\n  errors: ValidationError[];\n  /** List of warnings */\n  warnings: ValidationError[];\n}\n\n/**\n * Validator options\n */\nexport interface ValidatorOptions {\n  /** Strict mode (treat warnings as errors) */\n  strict?: boolean;\n  /** Known field types (for type validation) */\n  knownFieldTypes?: string[];\n  /** Known column types */\n  knownColumnTypes?: string[];\n  /** Custom validators */\n  customValidators?: Record<string, (value: unknown, path: string) => ValidationError[]>;\n}\n\n// =============================================================================\n// DEFAULT OPTIONS\n// =============================================================================\n\nconst DEFAULT_FIELD_TYPES = [\n  'text', 'number', 'email', 'password', 'tel', 'url',\n  'textarea', 'select', 'multiselect', 'checkbox', 'radio',\n  'switch', 'date', 'datetime', 'time', 'file', 'image',\n  'currency', 'percent', 'hidden', 'entity', 'generic',\n];\n\nconst DEFAULT_COLUMN_TYPES = [\n  'text', 'number', 'currency', 'percent', 'date', 'datetime',\n  'boolean', 'badge', 'link', 'image', 'actions', 'custom',\n];\n\n// =============================================================================\n// HELPER FUNCTIONS\n// =============================================================================\n\nfunction createError(\n  path: string,\n  message: string,\n  severity: 'error' | 'warning' = 'error',\n  suggestion?: string\n): ValidationError {\n  return { path, message, severity, suggestion };\n}\n\nfunction isNonEmptyString(value: unknown): value is string {\n  return typeof value === 'string' && value.trim().length > 0;\n}\n\nfunction isValidArray(value: unknown): value is unknown[] {\n  return Array.isArray(value);\n}\n\nfunction isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\n// =============================================================================\n// VALIDATION FUNCTIONS\n// =============================================================================\n\n/**\n * Validate a validation rule configuration\n */\nfunction validateValidationRule(\n  rule: unknown,\n  path: string\n): ValidationError[] {\n  const errors: ValidationError[] = [];\n\n  if (!isObject(rule)) {\n    errors.push(createError(path, 'Validation rule must be an object'));\n    return errors;\n  }\n\n  const r = rule as Record<string, unknown>;\n\n  // Check for known rule types\n  const knownRules = [\n    'required', 'min', 'max', 'minLength', 'maxLength',\n    'pattern', 'email', 'url', 'custom', 'match'\n  ];\n\n  const hasKnownRule = knownRules.some(k => k in r);\n  if (!hasKnownRule) {\n    errors.push(createError(\n      path,\n      'Validation rule has no known validation type',\n      'warning',\n      `Add one of: ${knownRules.join(', ')}`\n    ));\n  }\n\n  // Validate specific rules\n  if ('min' in r && typeof r.min !== 'number') {\n    errors.push(createError(`${path}.min`, 'min must be a number'));\n  }\n\n  if ('max' in r && typeof r.max !== 'number') {\n    errors.push(createError(`${path}.max`, 'max must be a number'));\n  }\n\n  if ('minLength' in r && typeof r.minLength !== 'number') {\n    errors.push(createError(`${path}.minLength`, 'minLength must be a number'));\n  }\n\n  if ('maxLength' in r && typeof r.maxLength !== 'number') {\n    errors.push(createError(`${path}.maxLength`, 'maxLength must be a number'));\n  }\n\n  if ('pattern' in r && typeof r.pattern !== 'string') {\n    errors.push(createError(`${path}.pattern`, 'pattern must be a string (regex)'));\n  }\n\n  if ('custom' in r && typeof r.custom !== 'function') {\n    errors.push(createError(\n      `${path}.custom`,\n      'custom must be a function',\n      'warning',\n      'Custom validators in JSON configs will be ignored'\n    ));\n  }\n\n  return errors;\n}\n\n/**\n * Validate condition group\n */\nfunction validateConditionGroup(\n  condition: unknown,\n  path: string\n): ValidationError[] {\n  const errors: ValidationError[] = [];\n\n  if (!isObject(condition)) {\n    errors.push(createError(path, 'Condition must be an object'));\n    return errors;\n  }\n\n  const c = condition as unknown as FieldCondition & {\n    conditions?: FieldCondition[];\n    logic?: 'and' | 'or';\n  };\n\n  if (!c.field && !c.conditions) {\n    errors.push(createError(\n      path,\n      'Condition must have either \"field\" or \"conditions\"',\n      'error',\n      'For single condition: { field: \"status\", operator: \"eq\", value: \"active\" }'\n    ));\n  }\n\n  if (c.field) {\n    if (!isNonEmptyString(c.field)) {\n      errors.push(createError(`${path}.field`, 'field must be a non-empty string'));\n    }\n\n    if (!c.operator) {\n      errors.push(createError(`${path}.operator`, 'operator is required'));\n    } else {\n      const validOperators = ['eq', 'neq', 'gt', 'gte', 'lt', 'lte', 'in', 'notIn', 'contains', 'startsWith', 'endsWith', 'empty', 'notEmpty'];\n      if (!validOperators.includes(c.operator)) {\n        errors.push(createError(\n          `${path}.operator`,\n          `Invalid operator: ${c.operator}`,\n          'error',\n          `Valid operators: ${validOperators.join(', ')}`\n        ));\n      }\n    }\n  }\n\n  if (c.conditions) {\n    if (!isValidArray(c.conditions)) {\n      errors.push(createError(`${path}.conditions`, 'conditions must be an array'));\n    } else {\n      (c.conditions as unknown[]).forEach((sub: unknown, i: number) => {\n        errors.push(...validateConditionGroup(sub, `${path}.conditions[${i}]`));\n      });\n    }\n\n    if (c.logic && !['and', 'or'].includes(c.logic)) {\n      errors.push(createError(\n        `${path}.logic`,\n        'logic must be \"and\" or \"or\"',\n        'error'\n      ));\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Validate a field configuration\n */\nfunction validateFieldConfig(\n  field: unknown,\n  path: string,\n  options: ValidatorOptions\n): ValidationError[] {\n  const errors: ValidationError[] = [];\n  const knownTypes = options.knownFieldTypes || DEFAULT_FIELD_TYPES;\n\n  if (!isObject(field)) {\n    errors.push(createError(path, 'Field configuration must be an object'));\n    return errors;\n  }\n\n  const f = field as unknown as FieldConfig;\n\n  // Required fields\n  if (!isNonEmptyString(f.name)) {\n    errors.push(createError(`${path}.name`, 'name is required and must be a non-empty string'));\n  }\n\n  if (!isNonEmptyString(f.type)) {\n    errors.push(createError(`${path}.type`, 'type is required'));\n  } else if (!knownTypes.includes(f.type) && f.type !== 'generic') {\n    errors.push(createError(\n      `${path}.type`,\n      `Unknown field type: ${f.type}`,\n      'warning',\n      `Known types: ${knownTypes.join(', ')}. Use \"generic\" for custom types.`\n    ));\n  }\n\n  // Label recommendation\n  if (!f.label) {\n    errors.push(createError(\n      `${path}.label`,\n      'label is recommended for accessibility',\n      'warning'\n    ));\n  }\n\n  // Validate options for select fields\n  if (['select', 'multiselect', 'radio'].includes(f.type)) {\n    if (!f.options && !f.entityType) {\n      errors.push(createError(\n        `${path}.options`,\n        `${f.type} field requires options or entityType`,\n        'error'\n      ));\n    }\n  }\n\n  // Validate validation rules\n  if (f.validation) {\n    if (isValidArray(f.validation)) {\n      f.validation.forEach((rule, i) => {\n        errors.push(...validateValidationRule(rule, `${path}.validation[${i}]`));\n      });\n    } else if (isObject(f.validation)) {\n      errors.push(...validateValidationRule(f.validation, `${path}.validation`));\n    }\n  }\n\n  // Validate showWhen\n  if (f.showWhen) {\n    errors.push(...validateConditionGroup(f.showWhen, `${path}.showWhen`));\n  }\n\n  // Validate computed fields\n  if (f.computed) {\n    if (!isObject(f.computed)) {\n      errors.push(createError(`${path}.computed`, 'computed must be an object'));\n    } else {\n      const c = f.computed as Record<string, unknown>;\n      if (!isNonEmptyString(c.formula)) {\n        errors.push(createError(`${path}.computed.formula`, 'computed.formula is required'));\n      }\n      if (!isValidArray(c.deps)) {\n        errors.push(createError(`${path}.computed.deps`, 'computed.deps must be an array of field names'));\n      }\n    }\n  }\n\n  // Validate format options\n  if (f.format) {\n    if (!isObject(f.format)) {\n      errors.push(createError(`${path}.format`, 'format must be an object'));\n    } else {\n      const fmt = f.format as Record<string, unknown>;\n      if (fmt.toFixed !== undefined) {\n        if (!Number.isInteger(fmt.toFixed) || (fmt.toFixed as number) < 0) {\n          errors.push(createError(`${path}.format.toFixed`, 'format.toFixed must be an integer >= 0'));\n        }\n      }\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Validate a form section\n */\nfunction validateFormSection(\n  section: unknown,\n  path: string,\n  options: ValidatorOptions\n): ValidationError[] {\n  const errors: ValidationError[] = [];\n\n  if (!isObject(section)) {\n    errors.push(createError(path, 'Section must be an object'));\n    return errors;\n  }\n\n  const s = section as unknown as FormSection;\n\n  // Validate fields\n  if (!isValidArray(s.fields)) {\n    errors.push(createError(`${path}.fields`, 'fields is required and must be an array'));\n  } else if (s.fields.length === 0) {\n    errors.push(createError(`${path}.fields`, 'fields array is empty', 'warning'));\n  } else {\n    s.fields.forEach((field, i) => {\n      errors.push(...validateFieldConfig(field, `${path}.fields[${i}]`, options));\n    });\n  }\n\n  // Validate showWhen\n  if (s.showWhen) {\n    errors.push(...validateConditionGroup(s.showWhen, `${path}.showWhen`));\n  }\n\n  return errors;\n}\n\n/**\n * Validate a column configuration\n */\nfunction validateColumnConfig(\n  column: unknown,\n  path: string,\n  options: ValidatorOptions\n): ValidationError[] {\n  const errors: ValidationError[] = [];\n  const knownTypes = options.knownColumnTypes || DEFAULT_COLUMN_TYPES;\n\n  if (!isObject(column)) {\n    errors.push(createError(path, 'Column configuration must be an object'));\n    return errors;\n  }\n\n  const c = column as unknown as ColumnConfig;\n\n  // Required fields\n  if (!isNonEmptyString(c.key)) {\n    errors.push(createError(`${path}.key`, 'key is required and must be a non-empty string'));\n  }\n\n  if (!isNonEmptyString(c.header)) {\n    errors.push(createError(\n      `${path}.header`,\n      'header is recommended',\n      'warning',\n      'Will display column key if header is not provided'\n    ));\n  }\n\n  // Validate type\n  if (c.type && !knownTypes.includes(c.type) && c.type !== 'custom') {\n    errors.push(createError(\n      `${path}.type`,\n      `Unknown column type: ${c.type}`,\n      'warning',\n      `Known types: ${knownTypes.join(', ')}`\n    ));\n  }\n\n  // Validate width\n  if (c.width !== undefined && typeof c.width !== 'number' && typeof c.width !== 'string') {\n    errors.push(createError(`${path}.width`, 'width must be a number or string'));\n  }\n\n  return errors;\n}\n\n// =============================================================================\n// MAIN VALIDATORS\n// =============================================================================\n\n/**\n * Validate a TableConfig\n */\nexport function validateTableConfig(\n  config: unknown,\n  options: ValidatorOptions = {}\n): ValidationResult {\n  const errors: ValidationError[] = [];\n\n  if (!isObject(config)) {\n    return {\n      valid: false,\n      errors: [createError('', 'Table config must be an object')],\n      warnings: [],\n    };\n  }\n\n  const c = config as unknown as TableConfig;\n\n  // Validate columns\n  if (!isValidArray(c.columns)) {\n    errors.push(createError('columns', 'columns is required and must be an array'));\n  } else if (c.columns.length === 0) {\n    errors.push(createError('columns', 'columns array is empty'));\n  } else {\n    c.columns.forEach((col, i) => {\n      errors.push(...validateColumnConfig(col, `columns[${i}]`, options));\n    });\n\n    // Check for duplicate keys\n    const keys = c.columns.map(col => col.key);\n    const duplicates = keys.filter((k, i) => keys.indexOf(k) !== i);\n    if (duplicates.length > 0) {\n      errors.push(createError(\n        'columns',\n        `Duplicate column keys: ${[...new Set(duplicates)].join(', ')}`,\n        'error'\n      ));\n    }\n  }\n\n  // Validate pagination\n  if (c.pagination !== undefined && typeof c.pagination !== 'boolean') {\n    if (isObject(c.pagination)) {\n      const p = c.pagination as Record<string, unknown>;\n      if (p.pageSize && typeof p.pageSize !== 'number') {\n        errors.push(createError('pagination.pageSize', 'pageSize must be a number'));\n      }\n    } else {\n      errors.push(createError('pagination', 'pagination must be boolean or object'));\n    }\n  }\n\n  // Apply custom validators\n  if (options.customValidators) {\n    for (const [key, validator] of Object.entries(options.customValidators)) {\n      const configObj = c as unknown as Record<string, unknown>;\n      if (key in configObj) {\n        errors.push(...validator(configObj[key], key));\n      }\n    }\n  }\n\n  // Separate errors and warnings\n  const actualErrors = errors.filter(e => e.severity === 'error');\n  const warnings = errors.filter(e => e.severity === 'warning');\n\n  return {\n    valid: options.strict ? errors.length === 0 : actualErrors.length === 0,\n    errors: actualErrors,\n    warnings,\n  };\n}\n\n/**\n * Validate a FormConfig\n */\nexport function validateFormConfig(\n  config: unknown,\n  options: ValidatorOptions = {}\n): ValidationResult {\n  const errors: ValidationError[] = [];\n\n  if (!isObject(config)) {\n    return {\n      valid: false,\n      errors: [createError('', 'Form config must be an object')],\n      warnings: [],\n    };\n  }\n\n  const c = config as unknown as FormConfig;\n\n  // Validate sections\n  if (!isValidArray(c.sections)) {\n    errors.push(createError('sections', 'sections is required and must be an array'));\n  } else if (c.sections.length === 0) {\n    errors.push(createError('sections', 'sections array is empty'));\n  } else {\n    c.sections.forEach((section, i) => {\n      errors.push(...validateFormSection(section, `sections[${i}]`, options));\n    });\n  }\n\n  // Check for duplicate field names\n  const allFields = c.sections?.flatMap(s => s.fields) || [];\n  const names = allFields.map(f => f.name);\n  const duplicates = names.filter((n, i) => names.indexOf(n) !== i);\n  if (duplicates.length > 0) {\n    errors.push(createError(\n      'sections',\n      `Duplicate field names: ${[...new Set(duplicates)].join(', ')}`,\n      'error'\n    ));\n  }\n\n  // Validate id\n  if (!isNonEmptyString(c.id)) {\n    errors.push(createError('id', 'id is recommended', 'warning'));\n  }\n\n  // Apply custom validators\n  if (options.customValidators) {\n    for (const [key, validator] of Object.entries(options.customValidators)) {\n      const configObj = c as unknown as Record<string, unknown>;\n      if (key in configObj) {\n        errors.push(...validator(configObj[key], key));\n      }\n    }\n  }\n\n  // Separate errors and warnings\n  const actualErrors = errors.filter(e => e.severity === 'error');\n  const warnings = errors.filter(e => e.severity === 'warning');\n\n  return {\n    valid: options.strict ? errors.length === 0 : actualErrors.length === 0,\n    errors: actualErrors,\n    warnings,\n  };\n}\n\n/**\n * Validate any config (auto-detects type)\n */\nexport function validateConfig(\n  config: unknown,\n  options: ValidatorOptions = {}\n): ValidationResult {\n  if (!isObject(config)) {\n    return {\n      valid: false,\n      errors: [createError('', 'Config must be an object')],\n      warnings: [],\n    };\n  }\n\n  const c = config as Record<string, unknown>;\n\n  // Detect type\n  if ('columns' in c) {\n    return validateTableConfig(config, options);\n  }\n\n  if ('sections' in c) {\n    return validateFormConfig(config, options);\n  }\n\n  return {\n    valid: false,\n    errors: [createError('', 'Unknown config type. Must have \"columns\" (table) or \"sections\" (form)')],\n    warnings: [],\n  };\n}\n\n// =============================================================================\n// UTILITY FUNCTIONS\n// =============================================================================\n\n/**\n * Format validation errors for display\n */\nexport function formatValidationErrors(result: ValidationResult): string {\n  const lines: string[] = [];\n\n  if (result.errors.length > 0) {\n    lines.push('Errors:');\n    result.errors.forEach(e => {\n      lines.push(`  ✗ ${e.path || 'root'}: ${e.message}`);\n      if (e.suggestion) {\n        lines.push(`    → ${e.suggestion}`);\n      }\n    });\n  }\n\n  if (result.warnings.length > 0) {\n    lines.push('Warnings:');\n    result.warnings.forEach(w => {\n      lines.push(`  ⚠ ${w.path || 'root'}: ${w.message}`);\n      if (w.suggestion) {\n        lines.push(`    → ${w.suggestion}`);\n      }\n    });\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Assert config is valid (throws on error)\n */\nexport function assertValidConfig(\n  config: unknown,\n  options: ValidatorOptions = {}\n): void {\n  const result = validateConfig(config, options);\n\n  if (!result.valid) {\n    throw new Error(`Invalid configuration:\\n${formatValidationErrors(result)}`);\n  }\n}\n\nexport default validateConfig;\n","/**\n * @fileoverview Config Parser - Parse and normalize JSON configurations\n * \n * Provides parsing and transformation of raw JSON configs into normalized\n * structures ready for use by components.\n * \n * @module config-system/ConfigParser\n */\n\nimport type {\n  TableConfig,\n  FormConfig,\n  ColumnConfig,\n  FieldConfig,\n  FieldType,\n  FormSection,\n  ValidationRule,\n  ColumnDataType,\n  DataRecord,\n} from '../core/types';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Raw column config (from JSON)\n */\nexport interface RawColumnConfig {\n  key: string;\n  header?: string;\n  type?: string;\n  accessor?: string;\n  [key: string]: unknown;\n}\n\n/**\n * Raw field config (from JSON)\n */\nexport interface RawFieldConfig {\n  name: string;\n  type: string;\n  label?: string;\n  [key: string]: unknown;\n}\n\n/**\n * Raw section config (from JSON)\n */\nexport interface RawSectionConfig {\n  id?: string;\n  title?: string;\n  fields: RawFieldConfig[];\n  [key: string]: unknown;\n}\n\n/**\n * Raw table config (from JSON)\n */\nexport interface RawTableConfig {\n  columns: RawColumnConfig[];\n  [key: string]: unknown;\n}\n\n/**\n * Raw form config (from JSON)\n */\nexport interface RawFormConfig {\n  id?: string;\n  title?: string;\n  sections: RawSectionConfig[];\n  entity?: string;\n  [key: string]: unknown;\n}\n\n/**\n * Parser options\n */\nexport interface ParserOptions {\n  /** Default column width */\n  defaultColumnWidth?: number | string;\n  /** Default column sortable */\n  defaultSortable?: boolean;\n  /** Default field required */\n  defaultRequired?: boolean;\n  /** Field name transformer */\n  transformFieldName?: (name: string) => string;\n  /** Column key transformer */\n  transformColumnKey?: (key: string) => string;\n  /** Generate labels from names/keys */\n  generateLabels?: boolean;\n  /** Custom field normalizers */\n  fieldNormalizers?: Record<string, (field: RawFieldConfig) => Partial<FieldConfig>>;\n  /** Custom column normalizers */\n  columnNormalizers?: Record<string, (column: RawColumnConfig) => Partial<ColumnConfig>>;\n}\n\n// =============================================================================\n// HELPER FUNCTIONS\n// =============================================================================\n\n/**\n * Convert string to title case for label generation\n */\nfunction toTitleCase(str: string): string {\n  return str\n    .replace(/([A-Z])/g, ' $1') // Add space before capitals\n    .replace(/[_-]/g, ' ') // Replace underscores and dashes\n    .replace(/\\s+/g, ' ') // Normalize spaces\n    .trim()\n    .replace(/^\\w/, c => c.toUpperCase()) // Capitalize first letter\n    .replace(/\\s\\w/g, c => c.toUpperCase()); // Capitalize after spaces\n}\n\n/**\n * Deep clone an object\n */\nfunction deepClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(deepClone) as unknown as T;\n  \n  const cloned: Record<string, unknown> = {};\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      cloned[key] = deepClone((obj as Record<string, unknown>)[key]);\n    }\n  }\n  return cloned as T;\n}\n\n/**\n * Merge defaults with user config\n */\nfunction mergeDefaults<T extends object>(defaults: Partial<T>, config: T): T {\n  const result = { ...defaults } as T;\n  \n  for (const key in config) {\n    if (Object.prototype.hasOwnProperty.call(config, key)) {\n      const value = config[key];\n      if (value !== undefined) {\n        result[key] = value;\n      }\n    }\n  }\n  \n  return result;\n}\n\n// =============================================================================\n// NORMALIZATION FUNCTIONS\n// =============================================================================\n\n/**\n * Normalize a validation rule\n */\nfunction normalizeValidationRule(rule: unknown): ValidationRule | null {\n  if (!rule || typeof rule !== 'object') return null;\n  \n  const r = rule as Record<string, unknown>;\n  \n  // If it already has type, treat as structured rule\n  if ('type' in r && typeof r.type === 'string') {\n    return {\n      type: r.type as ValidationRule['type'],\n      value: r.value as string | number | RegExp | undefined,\n      message: typeof r.message === 'string' ? r.message : undefined,\n    };\n  }\n  \n  // Convert shorthand format to structured rules\n  const rules: ValidationRule[] = [];\n  \n  if ('required' in r && r.required) {\n    rules.push({ type: 'required', message: typeof r.message === 'string' ? r.message : undefined });\n  }\n  if ('min' in r && typeof r.min === 'number') {\n    rules.push({ type: 'min', value: r.min });\n  }\n  if ('max' in r && typeof r.max === 'number') {\n    rules.push({ type: 'max', value: r.max });\n  }\n  if ('minLength' in r && typeof r.minLength === 'number') {\n    rules.push({ type: 'minLength', value: r.minLength });\n  }\n  if ('maxLength' in r && typeof r.maxLength === 'number') {\n    rules.push({ type: 'maxLength', value: r.maxLength });\n  }\n  if ('pattern' in r && typeof r.pattern === 'string') {\n    rules.push({ type: 'pattern', value: r.pattern });\n  }\n  if ('email' in r && r.email) {\n    rules.push({ type: 'email' });\n  }\n  if ('url' in r && r.url) {\n    rules.push({ type: 'url' });\n  }\n\n  return rules.length > 0 ? rules[0] : null;\n}\n\n/**\n * Condition (either single or compound)\n */\ntype ConditionOrGroup = {\n  field?: string;\n  operator?: string;\n  value?: unknown;\n  logic?: 'and' | 'or';\n  conditions?: ConditionOrGroup[];\n};\n\n/**\n * Normalize a condition group\n */\nfunction normalizeConditionGroup(condition: unknown): ConditionOrGroup | undefined {\n  if (!condition || typeof condition !== 'object') return undefined;\n  \n  const c = condition as Record<string, unknown>;\n  \n  // Simple condition\n  if (c.field && typeof c.field === 'string') {\n    return {\n      field: c.field,\n      operator: typeof c.operator === 'string' ? c.operator : 'equals',\n      value: c.value,\n    };\n  }\n  \n  // Compound condition\n  if (Array.isArray(c.conditions)) {\n    return {\n      logic: (c.logic as 'and' | 'or') || 'and',\n      conditions: c.conditions\n        .map(normalizeConditionGroup)\n        .filter((cond): cond is ConditionOrGroup => cond !== undefined),\n    };\n  }\n  \n  return undefined;\n}\n\n/**\n * Normalize a field configuration\n */\nfunction normalizeField(\n  raw: RawFieldConfig, \n  options: ParserOptions\n): FieldConfig {\n  const {\n    defaultRequired = false,\n    transformFieldName,\n    generateLabels = true,\n    fieldNormalizers = {},\n  } = options;\n\n  // Start with base normalization\n  const name = transformFieldName ? transformFieldName(raw.name) : raw.name;\n  \n  const normalized: FieldConfig = {\n    name,\n    type: (raw.type || 'text') as FieldType,\n    label: (raw.label || (generateLabels ? toTitleCase(name) : name)) as string,\n    required: (raw.required as boolean | undefined) ?? defaultRequired,\n    disabled: (raw.disabled as boolean | undefined) ?? false,\n    readOnly: (raw.readOnly as boolean | undefined) ?? false,\n    placeholder: raw.placeholder as string | undefined,\n    helpText: raw.helpText as string | undefined,\n    defaultValue: raw.defaultValue as FieldConfig['defaultValue'],\n  };\n\n  // Copy optional properties\n  if (raw.options) {\n    normalized.options = deepClone(raw.options) as FieldConfig['options'];\n  }\n\n  if (raw.entityType) {\n    normalized.entityType = raw.entityType as string;\n  }\n\n  if (raw.min !== undefined) normalized.min = raw.min as number;\n  if (raw.max !== undefined) normalized.max = raw.max as number;\n  if (raw.minLength !== undefined) normalized.minLength = raw.minLength as number;\n  if (raw.maxLength !== undefined) normalized.maxLength = raw.maxLength as number;\n\n  // Normalize validation\n  if (raw.validation) {\n    if (Array.isArray(raw.validation)) {\n      normalized.validation = raw.validation\n        .map(normalizeValidationRule)\n        .filter((r): r is ValidationRule => r !== null);\n    } else {\n      const rule = normalizeValidationRule(raw.validation);\n      if (rule) normalized.validation = [rule];\n    }\n  }\n\n  // Normalize showWhen\n  if (raw.showWhen) {\n    normalized.showWhen = normalizeConditionGroup(raw.showWhen) as FieldConfig['showWhen'];\n  }\n\n  // Normalize computed\n  if (raw.computed && typeof raw.computed === 'object') {\n    const c = raw.computed as Record<string, unknown>;\n    if (typeof c.formula === 'string' && Array.isArray(c.deps)) {\n      normalized.computed = {\n        formula: c.formula,\n        deps: c.deps.filter((d): d is string => typeof d === 'string'),\n      };\n    }\n  }\n\n  // Apply custom normalizer if exists\n  if (fieldNormalizers[raw.type]) {\n    Object.assign(normalized, fieldNormalizers[raw.type](raw));\n  }\n\n  // Copy any additional properties (for extensibility)\n  const knownKeys = new Set([\n    'name', 'type', 'label', 'required', 'disabled', 'readOnly',\n    'placeholder', 'helperText', 'defaultValue', 'options', 'entityType',\n    'min', 'max', 'minLength', 'maxLength', 'validation', 'showWhen', 'computed'\n  ]);\n\n  for (const key in raw) {\n    if (!knownKeys.has(key) && raw[key] !== undefined) {\n      (normalized as unknown as Record<string, unknown>)[key] = deepClone(raw[key]);\n    }\n  }\n\n  return normalized;\n}\n\n/**\n * Normalize a form section\n */\nfunction normalizeSection(\n  raw: RawSectionConfig,\n  options: ParserOptions\n): FormSection {\n  const normalized: FormSection = {\n    id: raw.id || (raw.title?.toLowerCase().replace(/\\s+/g, '-') ?? 'section'),\n    title: raw.title ?? 'Section',\n    description: raw.description as string | undefined,\n    collapsible: (raw.collapsible as boolean | undefined) ?? false,\n    defaultCollapsed: (raw.collapsed as boolean | undefined) ?? false,\n    fields: raw.fields.map(f => normalizeField(f, options)),\n  };\n\n  if (raw.showWhen) {\n    normalized.showWhen = normalizeConditionGroup(raw.showWhen) as FormSection['showWhen'];\n  }\n\n  // Copy columns layout\n  if (raw.columns) {\n    normalized.columns = raw.columns as number;\n  }\n\n  return normalized;\n}\n\n/**\n * Normalize a column configuration\n */\nfunction normalizeColumn(\n  raw: RawColumnConfig,\n  options: ParserOptions\n): ColumnConfig {\n  const {\n    defaultColumnWidth,\n    defaultSortable = true,\n    transformColumnKey,\n    generateLabels = true,\n    columnNormalizers = {},\n  } = options;\n\n  const key = transformColumnKey ? transformColumnKey(raw.key) : raw.key;\n\n  const normalized: ColumnConfig = {\n    key,\n    accessor: raw.accessor || key,\n    header: raw.header || (generateLabels ? toTitleCase(key) : key),\n    type: (raw.type || 'text') as ColumnDataType,\n    width: (typeof raw.width === 'string' || typeof raw.width === 'number') ? raw.width : defaultColumnWidth,\n    minWidth: raw.minWidth as string | number | undefined,\n    maxWidth: raw.maxWidth as string | number | undefined,\n    sortable: (raw.sortable as boolean | undefined) ?? defaultSortable,\n    filterable: (raw.filterable as boolean | undefined) ?? false,\n    visible: raw.hidden ? false : (raw.visible as boolean | undefined) ?? true,\n    align: (raw.align as ColumnConfig['align']) || 'left',\n  };\n\n  // Copy optional properties\n  if (raw.format) normalized.format = raw.format as ColumnConfig['format'];\n  if (raw.render) normalized.render = raw.render as ColumnConfig['render'];\n\n  // Apply custom normalizer if exists\n  const type = (raw.type || (raw as any).dataType || 'text') as string;\n  if (columnNormalizers[type]) {\n    Object.assign(normalized, columnNormalizers[type](raw));\n  }\n  // If dataType was provided (legacy), ensure it maps to type for downstream components\n  normalized.type = type as any;\n\n  // Copy any additional properties\n  const knownKeys = new Set([\n    'key', 'header', 'type', 'width', 'minWidth', 'maxWidth',\n    'sortable', 'filterable', 'hidden', 'align', 'format',\n    'render', 'accessor', 'sortAccessor', 'filterOptions'\n  ]);\n\n  for (const k in raw) {\n    if (!knownKeys.has(k) && raw[k] !== undefined) {\n      (normalized as unknown as Record<string, unknown>)[k] = deepClone(raw[k]);\n    }\n  }\n\n  return normalized;\n}\n\n// =============================================================================\n// MAIN PARSERS\n// =============================================================================\n\n/**\n * Parse a raw table config into a normalized TableConfig\n */\nexport function parseTableConfig(\n  raw: RawTableConfig,\n  options: ParserOptions = {}\n): TableConfig {\n  const columns = raw.columns.map(c => normalizeColumn(c, options));\n\n  const config: TableConfig = {\n    columns,\n    pagination: raw.pagination as TableConfig['pagination'],\n    selection: raw.selection as TableConfig['selection'],\n    filters: raw.filters as TableConfig['filters'],\n    striped: (raw.striped as boolean | undefined),\n    bordered: (raw.bordered as boolean | undefined),\n    compact: (raw.compact as boolean | undefined),\n    hoverable: (raw.hoverable as boolean | undefined),\n    emptyMessage: raw.emptyMessage as string | undefined,\n    loadingMessage: raw.loadingMessage as string | undefined,\n    rowKey: raw.rowKey as string | undefined,\n    defaultSortColumn: raw.defaultSortColumn as string | undefined,\n    defaultSortDirection: raw.defaultSortDirection as TableConfig['defaultSortDirection'],\n  };\n\n  // Copy any additional properties\n  const knownKeys = new Set([\n    'columns', 'pagination', 'selection', 'filters',\n    'striped', 'bordered', 'compact', 'hoverable',\n    'emptyMessage', 'loadingMessage', 'rowKey',\n    'defaultSortColumn', 'defaultSortDirection'\n  ]);\n\n  for (const key in raw) {\n    if (!knownKeys.has(key) && raw[key] !== undefined) {\n      (config as unknown as Record<string, unknown>)[key] = deepClone(raw[key]);\n    }\n  }\n\n  return config;\n}\n\n/**\n * Parse a raw form config into a normalized FormConfig\n */\nexport function parseFormConfig(\n  raw: RawFormConfig,\n  options: ParserOptions = {}\n): FormConfig {\n  const sections = raw.sections.map(s => normalizeSection(s, options));\n\n  const config: FormConfig = {\n    id: raw.id || 'form',\n    title: raw.title || 'Form',\n    sections,\n    submitLabel: raw.submitLabel as string | undefined,\n    cancelLabel: raw.cancelLabel as string | undefined,\n    showCancel: (raw.showCancel as boolean | undefined),\n    size: (raw.size as FormConfig['size']),\n    validationMode: (raw.validationMode as FormConfig['validationMode']),\n  };\n\n  // Copy any additional properties\n  const knownKeys = new Set([\n    'id', 'title', 'sections', 'entity', 'submitLabel', 'cancelLabel',\n    'showCancel', 'size', 'validationMode'\n  ]);\n\n  for (const key in raw) {\n    if (!knownKeys.has(key) && raw[key] !== undefined) {\n      (config as unknown as Record<string, unknown>)[key] = deepClone(raw[key]);\n    }\n  }\n\n  return config;\n}\n\n/**\n * Parse any config (auto-detects type)\n */\nexport function parseConfig<T extends TableConfig | FormConfig>(\n  raw: RawTableConfig | RawFormConfig,\n  options: ParserOptions = {}\n): T {\n  if ('columns' in raw) {\n    return parseTableConfig(raw as RawTableConfig, options) as T;\n  }\n\n  if ('sections' in raw) {\n    return parseFormConfig(raw as RawFormConfig, options) as T;\n  }\n\n  throw new Error('Unknown config type. Must have \"columns\" (table) or \"sections\" (form)');\n}\n\n// =============================================================================\n// CONFIG LOADER\n// =============================================================================\n\n/**\n * Config loader options\n */\nexport interface ConfigLoaderOptions extends ParserOptions {\n  /** Base path for config files */\n  basePath?: string;\n  /** Cache loaded configs */\n  cache?: boolean;\n  /** Validate on load */\n  validate?: boolean;\n}\n\n/**\n * Config loader for dynamically loading JSON configs\n */\nexport class ConfigLoader {\n  private cache: Map<string, TableConfig | FormConfig> = new Map();\n  private options: ConfigLoaderOptions;\n\n  constructor(options: ConfigLoaderOptions = {}) {\n    this.options = {\n      basePath: '/configs',\n      cache: true,\n      validate: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Load a config from URL or path\n   */\n  async load<T extends TableConfig | FormConfig>(path: string): Promise<T> {\n    // Check cache\n    if (this.options.cache && this.cache.has(path)) {\n      return this.cache.get(path) as T;\n    }\n\n    // Build full URL\n    const url = path.startsWith('http') \n      ? path \n      : `${this.options.basePath}/${path}`;\n\n    try {\n      const response = await fetch(url);\n      \n      if (!response.ok) {\n        throw new Error(`Failed to load config: ${response.statusText}`);\n      }\n\n      const raw = await response.json();\n      const parsed = parseConfig<T>(raw, this.options);\n\n      // Cache result\n      if (this.options.cache) {\n        this.cache.set(path, parsed);\n      }\n\n      return parsed;\n    } catch (error) {\n      throw new Error(`Failed to load config from ${path}: ${error}`);\n    }\n  }\n\n  /**\n   * Load multiple configs\n   */\n  async loadMany<T extends TableConfig | FormConfig>(paths: string[]): Promise<T[]> {\n    return Promise.all(paths.map(path => this.load<T>(path)));\n  }\n\n  /**\n   * Clear the cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Remove a specific config from cache\n   */\n  invalidate(path: string): void {\n    this.cache.delete(path);\n  }\n}\n\n/**\n * Create a config loader instance\n */\nexport function createConfigLoader(options?: ConfigLoaderOptions): ConfigLoader {\n  return new ConfigLoader(options);\n}\n\nexport default parseConfig;\n"]}